

<img src="//www.sqlalchemy.org/img/dbtoolkit6.gif"/>
The Database Toolkit for Python
<ul>
<li>
<a href="//www.sqlalchemy.org/">home</a>
</li>
<li>
<a href="#" id="feature-dropdown">
features
</a>
<ul>
<li><a href="//www.sqlalchemy.org/philosophy.html">Philosophy Statement</a></li>
<li><a href="//www.sqlalchemy.org/features.html">Feature Overview</a></li>
<li><a href="//www.sqlalchemy.org/quotes.html">Testimonials</a></li>
</ul>
</li>
<li>
<a href="//www.sqlalchemy.org/blog/">news</a>
</li>
<li>
<a href="#" id="docs-dropdown">
documentation
</a>
<ul>
<li><a href="//docs.sqlalchemy.org">Current Documentation (version 2.0)</a></li>
<li></li>
<li><a href="//www.sqlalchemy.org/library.html#reference">Documentation by Version</a></li>
<li>
<a href="//docs.sqlalchemy.org/en/21/">
Version 2.1 (development)
</a>
</li>
<li>
<a href="//docs.sqlalchemy.org/en/20/">
Version 2.0
</a>
</li>
<li>
<a href="//docs.sqlalchemy.org/en/14/">
Version 1.4
</a>
</li>
<li>
<a href="//docs.sqlalchemy.org/en/13/">
Version 1.3
</a>
</li>
<li></li>
<li><a href="//www.sqlalchemy.org/library.html#talks">Talks and Tutorials</a></li>
<li><a href="//www.sqlalchemy.org/library.html">Published content overview</a></li>
</ul>
</li>
<li>
<a href="#" id="community-dropdown">
community
</a>
<ul>
<li><a href="//www.sqlalchemy.org/support.html">Get Support</a></li>
<li><a href="//www.sqlalchemy.org/participate.html">Participate</a></li>
<li><a href="//www.sqlalchemy.org/develop.html">Develop</a></li>
<li><a href="//www.sqlalchemy.org/codeofconduct.html">Code of Conduct</a></li>
<li><a href="https://github.com/sqlalchemy/sqlalchemy">Github</a></li>
</ul>
</li>
<li>
<a href="#" id="download-dropdown">
download
</a>
<ul>
<li><a href="//www.sqlalchemy.org/download.html">Download</a>
<li><a href="//www.sqlalchemy.org/download.html#current">Current Release Series (2.0)</a></li>
<li><a href="//www.sqlalchemy.org/download.html#maintenance">Maintenance Release (1.4)</a></li>
<li><a href="//www.sqlalchemy.org/download.html#development">Development Access</a></li>
<li><a href="//www.sqlalchemy.org/download.html#license">License</a></li>
<li><a href="//www.sqlalchemy.org/download.html#versions">Version Numbering</a></li>
<li><a href="//www.sqlalchemy.org/download.html#relstatus">Release Status</a></li>
</li></ul>
</li>
</ul>
Release: 2.0.31
current release
| Release Date: June 18, 2024

<h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>
<h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
<p id="sidebar-current">current release</p>
<p id="sidebar-topnav">
<a href="../index.html">Home</a>
| <a href="//docs.sqlalchemy.org/20/sqlalchemy_20.zip">Download this Documentation</a>
</p>
Search terms:

<h3>
<a href="index.html">SQLAlchemy Core</a>
</h3>
<ul>
<li><a href="expression_api.html">SQL Statements and Expressions API</a><ul>
<li>Column Elements and Expressions<a href="#">Â¶</a><ul>
<li><a href="#column-element-foundational-constructors">Column Element Foundational Constructors</a><ul>
<li><a href="#sqlalchemy.sql.expression.and_">and_()</a></li>
<li><a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a></li>
<li><a href="#sqlalchemy.sql.expression.bitwise_not">bitwise_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.case">case()</a></li>
<li><a href="#sqlalchemy.sql.expression.cast">cast()</a></li>
<li><a href="#sqlalchemy.sql.expression.column">column()</a></li>
<li><a href="#sqlalchemy.sql.expression.custom_op">custom_op</a></li>
<li><a href="#sqlalchemy.sql.expression.distinct">distinct()</a></li>
<li><a href="#sqlalchemy.sql.expression.extract">extract()</a></li>
<li><a href="#sqlalchemy.sql.expression.false">false()</a></li>
<li><a href="#sqlalchemy.sql.expression.func">func</a></li>
<li><a href="#sqlalchemy.sql.expression.lambda_stmt">lambda_stmt()</a></li>
<li><a href="#sqlalchemy.sql.expression.literal">literal()</a></li>
<li><a href="#sqlalchemy.sql.expression.literal_column">literal_column()</a></li>
<li><a href="#sqlalchemy.sql.expression.not_">not_()</a></li>
<li><a href="#sqlalchemy.sql.expression.null">null()</a></li>
<li><a href="#sqlalchemy.sql.expression.or_">or_()</a></li>
<li><a href="#sqlalchemy.sql.expression.outparam">outparam()</a></li>
<li><a href="#sqlalchemy.sql.expression.text">text()</a></li>
<li><a href="#sqlalchemy.sql.expression.true">true()</a></li>
<li><a href="#sqlalchemy.sql.expression.try_cast">try_cast()</a></li>
<li><a href="#sqlalchemy.sql.expression.tuple_">tuple_()</a></li>
<li><a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a></li>
<li><a href="#sqlalchemy.sql.expression.quoted_name">quoted_name</a><ul>
<li><a href="#sqlalchemy.sql.expression.quoted_name.quote">quoted_name.quote</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#column-element-modifier-constructors">Column Element Modifier Constructors</a><ul>
<li><a href="#sqlalchemy.sql.expression.all_">all_()</a></li>
<li><a href="#sqlalchemy.sql.expression.any_">any_()</a></li>
<li><a href="#sqlalchemy.sql.expression.asc">asc()</a></li>
<li><a href="#sqlalchemy.sql.expression.between">between()</a></li>
<li><a href="#sqlalchemy.sql.expression.collate">collate()</a></li>
<li><a href="#sqlalchemy.sql.expression.desc">desc()</a></li>
<li><a href="#sqlalchemy.sql.expression.funcfilter">funcfilter()</a></li>
<li><a href="#sqlalchemy.sql.expression.label">label()</a></li>
<li><a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a></li>
<li><a href="#sqlalchemy.sql.expression.nullsfirst">nullsfirst()</a></li>
<li><a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a></li>
<li><a href="#sqlalchemy.sql.expression.nullslast">nullslast()</a></li>
<li><a href="#sqlalchemy.sql.expression.over">over()</a></li>
<li><a href="#sqlalchemy.sql.expression.within_group">within_group()</a></li>
</ul>
</li>
<li><a href="#column-element-class-documentation">Column Element Class Documentation</a><ul>
<li><a href="#sqlalchemy.sql.expression.BinaryExpression">BinaryExpression</a></li>
<li><a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a><ul>
<li><a href="#sqlalchemy.sql.expression.BindParameter.effective_value">BindParameter.effective_value</a></li>
<li><a href="#sqlalchemy.sql.expression.BindParameter.inherit_cache">BindParameter.inherit_cache</a></li>
<li><a href="#sqlalchemy.sql.expression.BindParameter.render_literal_execute">BindParameter.render_literal_execute()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Case">Case</a></li>
<li><a href="#sqlalchemy.sql.expression.Cast">Cast</a></li>
<li><a href="#sqlalchemy.sql.expression.ClauseList">ClauseList</a><ul>
<li><a href="#sqlalchemy.sql.expression.ClauseList.self_group">ClauseList.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a><ul>
<li><a href="#sqlalchemy.sql.expression.ColumnClause.get_children">ColumnClause.get_children()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a><ul>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.add">ColumnCollection.add()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.as_readonly">ColumnCollection.as_readonly()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.clear">ColumnCollection.clear()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.compare">ColumnCollection.compare()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.contains_column">ColumnCollection.contains_column()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.corresponding_column">ColumnCollection.corresponding_column()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.get">ColumnCollection.get()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.items">ColumnCollection.items()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.keys">ColumnCollection.keys()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.update">ColumnCollection.update()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.values">ColumnCollection.values()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a><ul>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.__eq__">ColumnElement.__eq__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.__le__">ColumnElement.__le__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.__lt__">ColumnElement.__lt__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.__ne__">ColumnElement.__ne__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.all_">ColumnElement.all_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.allows_lambda">ColumnElement.allows_lambda</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.anon_key_label">ColumnElement.anon_key_label</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.anon_label">ColumnElement.anon_label</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.any_">ColumnElement.any_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.asc">ColumnElement.asc()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.base_columns">ColumnElement.base_columns</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.between">ColumnElement.between()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_and">ColumnElement.bitwise_and()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_lshift">ColumnElement.bitwise_lshift()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_not">ColumnElement.bitwise_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_or">ColumnElement.bitwise_or()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_rshift">ColumnElement.bitwise_rshift()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_xor">ColumnElement.bitwise_xor()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bool_op">ColumnElement.bool_op()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.cast">ColumnElement.cast()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.collate">ColumnElement.collate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.comparator">ColumnElement.comparator</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.compare">ColumnElement.compare()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.compile">ColumnElement.compile()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.concat">ColumnElement.concat()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.contains">ColumnElement.contains()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.desc">ColumnElement.desc()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.description">ColumnElement.description</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.distinct">ColumnElement.distinct()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.endswith">ColumnElement.endswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.entity_namespace">ColumnElement.entity_namespace</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.expression">ColumnElement.expression</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.foreign_keys">ColumnElement.foreign_keys</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.get_children">ColumnElement.get_children()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.icontains">ColumnElement.icontains()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.iendswith">ColumnElement.iendswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.ilike">ColumnElement.ilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.in_">ColumnElement.in_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.inherit_cache">ColumnElement.inherit_cache</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_">ColumnElement.is_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_clause_element">ColumnElement.is_clause_element</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_distinct_from">ColumnElement.is_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_dml">ColumnElement.is_dml</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_not">ColumnElement.is_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_not_distinct_from">ColumnElement.is_not_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_selectable">ColumnElement.is_selectable</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.isnot">ColumnElement.isnot()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.isnot_distinct_from">ColumnElement.isnot_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.istartswith">ColumnElement.istartswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.key">ColumnElement.key</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.label">ColumnElement.label()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.like">ColumnElement.like()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.match">ColumnElement.match()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.negation_clause">ColumnElement.negation_clause</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.not_ilike">ColumnElement.not_ilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.not_in">ColumnElement.not_in()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.not_like">ColumnElement.not_like()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.notilike">ColumnElement.notilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.notin_">ColumnElement.notin_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.notlike">ColumnElement.notlike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.nulls_first">ColumnElement.nulls_first()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.nulls_last">ColumnElement.nulls_last()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.nullsfirst">ColumnElement.nullsfirst()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.nullslast">ColumnElement.nullslast()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.op">ColumnElement.op()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.operate">ColumnElement.operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.params">ColumnElement.params()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.primary_key">ColumnElement.primary_key</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.proxy_set">ColumnElement.proxy_set</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.regexp_match">ColumnElement.regexp_match()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.regexp_replace">ColumnElement.regexp_replace()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.reverse_operate">ColumnElement.reverse_operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.self_group">ColumnElement.self_group()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.shares_lineage">ColumnElement.shares_lineage()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.startswith">ColumnElement.startswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.stringify_dialect">ColumnElement.stringify_dialect</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.supports_execution">ColumnElement.supports_execution</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.timetuple">ColumnElement.timetuple</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.type">ColumnElement.type</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.unique_params">ColumnElement.unique_params()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.uses_inspection">ColumnElement.uses_inspection</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.ColumnExpressionArgument">ColumnExpressionArgument</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><ul>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__add__">ColumnOperators.__add__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__and__">ColumnOperators.__and__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__eq__">ColumnOperators.__eq__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__floordiv__">ColumnOperators.__floordiv__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__ge__">ColumnOperators.__ge__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__getitem__">ColumnOperators.__getitem__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__gt__">ColumnOperators.__gt__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__hash__">ColumnOperators.__hash__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__invert__">ColumnOperators.__invert__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__le__">ColumnOperators.__le__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__lshift__">ColumnOperators.__lshift__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__lt__">ColumnOperators.__lt__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__mod__">ColumnOperators.__mod__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__mul__">ColumnOperators.__mul__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__ne__">ColumnOperators.__ne__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__neg__">ColumnOperators.__neg__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__or__">ColumnOperators.__or__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__radd__">ColumnOperators.__radd__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__">ColumnOperators.__rfloordiv__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rmod__">ColumnOperators.__rmod__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rmul__">ColumnOperators.__rmul__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rshift__">ColumnOperators.__rshift__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rsub__">ColumnOperators.__rsub__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rtruediv__">ColumnOperators.__rtruediv__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__sa_operate__">ColumnOperators.__sa_operate__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__sub__">ColumnOperators.__sub__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__truediv__">ColumnOperators.__truediv__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.all_">ColumnOperators.all_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.any_">ColumnOperators.any_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.asc">ColumnOperators.asc()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.between">ColumnOperators.between()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_and">ColumnOperators.bitwise_and()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift">ColumnOperators.bitwise_lshift()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_not">ColumnOperators.bitwise_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_or">ColumnOperators.bitwise_or()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift">ColumnOperators.bitwise_rshift()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor">ColumnOperators.bitwise_xor()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bool_op">ColumnOperators.bool_op()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.collate">ColumnOperators.collate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.concat">ColumnOperators.concat()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.desc">ColumnOperators.desc()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.distinct">ColumnOperators.distinct()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.icontains">ColumnOperators.icontains()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith">ColumnOperators.iendswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.is_">ColumnOperators.is_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from">ColumnOperators.is_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.is_not">ColumnOperators.is_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from">ColumnOperators.is_not_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.isnot">ColumnOperators.isnot()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from">ColumnOperators.isnot_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith">ColumnOperators.istartswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.match">ColumnOperators.match()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.not_ilike">ColumnOperators.not_ilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.not_in">ColumnOperators.not_in()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.not_like">ColumnOperators.not_like()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.notilike">ColumnOperators.notilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.notin_">ColumnOperators.notin_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.notlike">ColumnOperators.notlike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_first">ColumnOperators.nulls_first()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_last">ColumnOperators.nulls_last()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.nullsfirst">ColumnOperators.nullsfirst()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.nullslast">ColumnOperators.nullslast()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.op">ColumnOperators.op()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.operate">ColumnOperators.operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match">ColumnOperators.regexp_match()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace">ColumnOperators.regexp_replace()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.reverse_operate">ColumnOperators.reverse_operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.timetuple">ColumnOperators.timetuple</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Extract">Extract</a></li>
<li><a href="#sqlalchemy.sql.expression.False_">False_</a></li>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter">FunctionFilter</a><ul>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter.filter">FunctionFilter.filter()</a></li>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter.over">FunctionFilter.over()</a></li>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter.self_group">FunctionFilter.self_group()</a></li>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter.within_group">FunctionFilter.within_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Label">Label</a><ul>
<li><a href="#sqlalchemy.sql.expression.Label.foreign_keys">Label.foreign_keys</a></li>
<li><a href="#sqlalchemy.sql.expression.Label.primary_key">Label.primary_key</a></li>
<li><a href="#sqlalchemy.sql.expression.Label.self_group">Label.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Null">Null</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators">Operators</a><ul>
<li><a href="#sqlalchemy.sql.expression.Operators.__and__">Operators.__and__()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.__invert__">Operators.__invert__()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.__or__">Operators.__or__()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.__sa_operate__">Operators.__sa_operate__()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.operate">Operators.operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.reverse_operate">Operators.reverse_operate()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Over">Over</a><ul>
<li><a href="#sqlalchemy.sql.expression.Over.element">Over.element</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.SQLColumnExpression">SQLColumnExpression</a></li>
<li><a href="#sqlalchemy.sql.expression.TextClause">TextClause</a><ul>
<li><a href="#sqlalchemy.sql.expression.TextClause.bindparams">TextClause.bindparams()</a></li>
<li><a href="#sqlalchemy.sql.expression.TextClause.columns">TextClause.columns()</a></li>
<li><a href="#sqlalchemy.sql.expression.TextClause.self_group">TextClause.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.TryCast">TryCast</a><ul>
<li><a href="#sqlalchemy.sql.expression.TryCast.inherit_cache">TryCast.inherit_cache</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Tuple">Tuple</a><ul>
<li><a href="#sqlalchemy.sql.expression.Tuple.self_group">Tuple.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a><ul>
<li><a href="#sqlalchemy.sql.expression.WithinGroup.filter">WithinGroup.filter()</a></li>
<li><a href="#sqlalchemy.sql.expression.WithinGroup.over">WithinGroup.over()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.elements.WrapsColumnExpression">WrapsColumnExpression</a></li>
<li><a href="#sqlalchemy.sql.expression.True_">True_</a></li>
<li><a href="#sqlalchemy.sql.expression.TypeCoerce">TypeCoerce</a><ul>
<li><a href="#sqlalchemy.sql.expression.TypeCoerce.self_group">TypeCoerce.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a><ul>
<li><a href="#sqlalchemy.sql.expression.UnaryExpression.self_group">UnaryExpression.self_group()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#column-element-typing-utilities">Column Element Typing Utilities</a><ul>
<li><a href="#sqlalchemy.NotNullable">NotNullable()</a></li>
<li><a href="#sqlalchemy.Nullable">Nullable()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="operators.html">Operator Reference</a></li>
<li><a href="selectable.html">SELECT and Related Constructs</a></li>
<li><a href="dml.html">Insert, Updates, Deletes</a></li>
<li><a href="functions.html">SQL and Generic Functions</a></li>
<li><a href="compiler.html">Custom SQL Constructs and Compilation Extension</a></li>
<li><a href="serializer.html">Expression Serializer Extension</a></li>
<li><a href="foundation.html">SQL Expression Language Foundational Constructs</a></li>
<li><a href="visitors.html">Visitor and Traversal Utilities</a></li>
</ul>
</li>
<li><a href="schema.html">Schema Definition Language</a></li>
<li><a href="types.html">SQL Datatype Objects</a></li>
<li><a href="engines_connections.html">Engine and Connection Use</a></li>
<li><a href="api_basics.html">Core API Basics</a></li>
</ul>
<h4>Project Versions</h4>
<ul>
<li><a href="../index.html">2.0.31</a></li>
</ul>
Search terms:

<p>
<a href="../index.html">Home</a>
| <a href="//docs.sqlalchemy.org/20/sqlalchemy_20.zip">Download this Documentation</a>
</p>
<ul>
<li>Previous:
<a href="expression_api.html">SQL Statements and Expressions API</a></li>
<li>Next:
<a href="operators.html">Operator Reference</a></li>
<li>Up: <a href="../index.html">Home</a></li>
<ul><li><a href="index.html">SQLAlchemy Core</a></li>
<ul><li><a href="expression_api.html">SQL Statements and Expressions API</a></li>
</ul>
</ul>
<li>On this page:</li>
<ul>
<li><a href="#column-elements-and-expressions">Column Elements and Expressions</a><ul>
<li><a href="#column-element-foundational-constructors">Column Element Foundational Constructors</a><ul>
<li><a href="#sqlalchemy.sql.expression.and_">and_()</a></li>
<li><a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a></li>
<li><a href="#sqlalchemy.sql.expression.bitwise_not">bitwise_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.case">case()</a></li>
<li><a href="#sqlalchemy.sql.expression.cast">cast()</a></li>
<li><a href="#sqlalchemy.sql.expression.column">column()</a></li>
<li><a href="#sqlalchemy.sql.expression.custom_op">custom_op</a></li>
<li><a href="#sqlalchemy.sql.expression.distinct">distinct()</a></li>
<li><a href="#sqlalchemy.sql.expression.extract">extract()</a></li>
<li><a href="#sqlalchemy.sql.expression.false">false()</a></li>
<li><a href="#sqlalchemy.sql.expression.func">func</a></li>
<li><a href="#sqlalchemy.sql.expression.lambda_stmt">lambda_stmt()</a></li>
<li><a href="#sqlalchemy.sql.expression.literal">literal()</a></li>
<li><a href="#sqlalchemy.sql.expression.literal_column">literal_column()</a></li>
<li><a href="#sqlalchemy.sql.expression.not_">not_()</a></li>
<li><a href="#sqlalchemy.sql.expression.null">null()</a></li>
<li><a href="#sqlalchemy.sql.expression.or_">or_()</a></li>
<li><a href="#sqlalchemy.sql.expression.outparam">outparam()</a></li>
<li><a href="#sqlalchemy.sql.expression.text">text()</a></li>
<li><a href="#sqlalchemy.sql.expression.true">true()</a></li>
<li><a href="#sqlalchemy.sql.expression.try_cast">try_cast()</a></li>
<li><a href="#sqlalchemy.sql.expression.tuple_">tuple_()</a></li>
<li><a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a></li>
<li><a href="#sqlalchemy.sql.expression.quoted_name">quoted_name</a><ul>
<li><a href="#sqlalchemy.sql.expression.quoted_name.quote">quoted_name.quote</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#column-element-modifier-constructors">Column Element Modifier Constructors</a><ul>
<li><a href="#sqlalchemy.sql.expression.all_">all_()</a></li>
<li><a href="#sqlalchemy.sql.expression.any_">any_()</a></li>
<li><a href="#sqlalchemy.sql.expression.asc">asc()</a></li>
<li><a href="#sqlalchemy.sql.expression.between">between()</a></li>
<li><a href="#sqlalchemy.sql.expression.collate">collate()</a></li>
<li><a href="#sqlalchemy.sql.expression.desc">desc()</a></li>
<li><a href="#sqlalchemy.sql.expression.funcfilter">funcfilter()</a></li>
<li><a href="#sqlalchemy.sql.expression.label">label()</a></li>
<li><a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a></li>
<li><a href="#sqlalchemy.sql.expression.nullsfirst">nullsfirst()</a></li>
<li><a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a></li>
<li><a href="#sqlalchemy.sql.expression.nullslast">nullslast()</a></li>
<li><a href="#sqlalchemy.sql.expression.over">over()</a></li>
<li><a href="#sqlalchemy.sql.expression.within_group">within_group()</a></li>
</ul>
</li>
<li><a href="#column-element-class-documentation">Column Element Class Documentation</a><ul>
<li><a href="#sqlalchemy.sql.expression.BinaryExpression">BinaryExpression</a></li>
<li><a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a><ul>
<li><a href="#sqlalchemy.sql.expression.BindParameter.effective_value">BindParameter.effective_value</a></li>
<li><a href="#sqlalchemy.sql.expression.BindParameter.inherit_cache">BindParameter.inherit_cache</a></li>
<li><a href="#sqlalchemy.sql.expression.BindParameter.render_literal_execute">BindParameter.render_literal_execute()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Case">Case</a></li>
<li><a href="#sqlalchemy.sql.expression.Cast">Cast</a></li>
<li><a href="#sqlalchemy.sql.expression.ClauseList">ClauseList</a><ul>
<li><a href="#sqlalchemy.sql.expression.ClauseList.self_group">ClauseList.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a><ul>
<li><a href="#sqlalchemy.sql.expression.ColumnClause.get_children">ColumnClause.get_children()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a><ul>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.add">ColumnCollection.add()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.as_readonly">ColumnCollection.as_readonly()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.clear">ColumnCollection.clear()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.compare">ColumnCollection.compare()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.contains_column">ColumnCollection.contains_column()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.corresponding_column">ColumnCollection.corresponding_column()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.get">ColumnCollection.get()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.items">ColumnCollection.items()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.keys">ColumnCollection.keys()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.update">ColumnCollection.update()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnCollection.values">ColumnCollection.values()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a><ul>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.__eq__">ColumnElement.__eq__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.__le__">ColumnElement.__le__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.__lt__">ColumnElement.__lt__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.__ne__">ColumnElement.__ne__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.all_">ColumnElement.all_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.allows_lambda">ColumnElement.allows_lambda</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.anon_key_label">ColumnElement.anon_key_label</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.anon_label">ColumnElement.anon_label</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.any_">ColumnElement.any_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.asc">ColumnElement.asc()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.base_columns">ColumnElement.base_columns</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.between">ColumnElement.between()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_and">ColumnElement.bitwise_and()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_lshift">ColumnElement.bitwise_lshift()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_not">ColumnElement.bitwise_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_or">ColumnElement.bitwise_or()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_rshift">ColumnElement.bitwise_rshift()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_xor">ColumnElement.bitwise_xor()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.bool_op">ColumnElement.bool_op()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.cast">ColumnElement.cast()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.collate">ColumnElement.collate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.comparator">ColumnElement.comparator</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.compare">ColumnElement.compare()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.compile">ColumnElement.compile()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.concat">ColumnElement.concat()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.contains">ColumnElement.contains()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.desc">ColumnElement.desc()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.description">ColumnElement.description</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.distinct">ColumnElement.distinct()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.endswith">ColumnElement.endswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.entity_namespace">ColumnElement.entity_namespace</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.expression">ColumnElement.expression</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.foreign_keys">ColumnElement.foreign_keys</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.get_children">ColumnElement.get_children()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.icontains">ColumnElement.icontains()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.iendswith">ColumnElement.iendswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.ilike">ColumnElement.ilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.in_">ColumnElement.in_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.inherit_cache">ColumnElement.inherit_cache</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_">ColumnElement.is_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_clause_element">ColumnElement.is_clause_element</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_distinct_from">ColumnElement.is_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_dml">ColumnElement.is_dml</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_not">ColumnElement.is_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_not_distinct_from">ColumnElement.is_not_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.is_selectable">ColumnElement.is_selectable</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.isnot">ColumnElement.isnot()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.isnot_distinct_from">ColumnElement.isnot_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.istartswith">ColumnElement.istartswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.key">ColumnElement.key</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.label">ColumnElement.label()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.like">ColumnElement.like()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.match">ColumnElement.match()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.negation_clause">ColumnElement.negation_clause</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.not_ilike">ColumnElement.not_ilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.not_in">ColumnElement.not_in()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.not_like">ColumnElement.not_like()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.notilike">ColumnElement.notilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.notin_">ColumnElement.notin_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.notlike">ColumnElement.notlike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.nulls_first">ColumnElement.nulls_first()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.nulls_last">ColumnElement.nulls_last()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.nullsfirst">ColumnElement.nullsfirst()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.nullslast">ColumnElement.nullslast()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.op">ColumnElement.op()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.operate">ColumnElement.operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.params">ColumnElement.params()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.primary_key">ColumnElement.primary_key</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.proxy_set">ColumnElement.proxy_set</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.regexp_match">ColumnElement.regexp_match()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.regexp_replace">ColumnElement.regexp_replace()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.reverse_operate">ColumnElement.reverse_operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.self_group">ColumnElement.self_group()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.shares_lineage">ColumnElement.shares_lineage()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.startswith">ColumnElement.startswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.stringify_dialect">ColumnElement.stringify_dialect</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.supports_execution">ColumnElement.supports_execution</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.timetuple">ColumnElement.timetuple</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.type">ColumnElement.type</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.unique_params">ColumnElement.unique_params()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnElement.uses_inspection">ColumnElement.uses_inspection</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.ColumnExpressionArgument">ColumnExpressionArgument</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><ul>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__add__">ColumnOperators.__add__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__and__">ColumnOperators.__and__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__eq__">ColumnOperators.__eq__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__floordiv__">ColumnOperators.__floordiv__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__ge__">ColumnOperators.__ge__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__getitem__">ColumnOperators.__getitem__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__gt__">ColumnOperators.__gt__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__hash__">ColumnOperators.__hash__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__invert__">ColumnOperators.__invert__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__le__">ColumnOperators.__le__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__lshift__">ColumnOperators.__lshift__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__lt__">ColumnOperators.__lt__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__mod__">ColumnOperators.__mod__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__mul__">ColumnOperators.__mul__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__ne__">ColumnOperators.__ne__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__neg__">ColumnOperators.__neg__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__or__">ColumnOperators.__or__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__radd__">ColumnOperators.__radd__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__">ColumnOperators.__rfloordiv__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rmod__">ColumnOperators.__rmod__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rmul__">ColumnOperators.__rmul__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rshift__">ColumnOperators.__rshift__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rsub__">ColumnOperators.__rsub__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__rtruediv__">ColumnOperators.__rtruediv__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__sa_operate__">ColumnOperators.__sa_operate__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__sub__">ColumnOperators.__sub__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.__truediv__">ColumnOperators.__truediv__()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.all_">ColumnOperators.all_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.any_">ColumnOperators.any_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.asc">ColumnOperators.asc()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.between">ColumnOperators.between()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_and">ColumnOperators.bitwise_and()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift">ColumnOperators.bitwise_lshift()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_not">ColumnOperators.bitwise_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_or">ColumnOperators.bitwise_or()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift">ColumnOperators.bitwise_rshift()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor">ColumnOperators.bitwise_xor()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.bool_op">ColumnOperators.bool_op()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.collate">ColumnOperators.collate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.concat">ColumnOperators.concat()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.desc">ColumnOperators.desc()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.distinct">ColumnOperators.distinct()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.icontains">ColumnOperators.icontains()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith">ColumnOperators.iendswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.is_">ColumnOperators.is_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from">ColumnOperators.is_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.is_not">ColumnOperators.is_not()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from">ColumnOperators.is_not_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.isnot">ColumnOperators.isnot()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from">ColumnOperators.isnot_distinct_from()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith">ColumnOperators.istartswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.match">ColumnOperators.match()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.not_ilike">ColumnOperators.not_ilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.not_in">ColumnOperators.not_in()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.not_like">ColumnOperators.not_like()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.notilike">ColumnOperators.notilike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.notin_">ColumnOperators.notin_()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.notlike">ColumnOperators.notlike()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_first">ColumnOperators.nulls_first()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_last">ColumnOperators.nulls_last()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.nullsfirst">ColumnOperators.nullsfirst()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.nullslast">ColumnOperators.nullslast()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.op">ColumnOperators.op()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.operate">ColumnOperators.operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match">ColumnOperators.regexp_match()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace">ColumnOperators.regexp_replace()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.reverse_operate">ColumnOperators.reverse_operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a></li>
<li><a href="#sqlalchemy.sql.expression.ColumnOperators.timetuple">ColumnOperators.timetuple</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Extract">Extract</a></li>
<li><a href="#sqlalchemy.sql.expression.False_">False_</a></li>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter">FunctionFilter</a><ul>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter.filter">FunctionFilter.filter()</a></li>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter.over">FunctionFilter.over()</a></li>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter.self_group">FunctionFilter.self_group()</a></li>
<li><a href="#sqlalchemy.sql.expression.FunctionFilter.within_group">FunctionFilter.within_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Label">Label</a><ul>
<li><a href="#sqlalchemy.sql.expression.Label.foreign_keys">Label.foreign_keys</a></li>
<li><a href="#sqlalchemy.sql.expression.Label.primary_key">Label.primary_key</a></li>
<li><a href="#sqlalchemy.sql.expression.Label.self_group">Label.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Null">Null</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators">Operators</a><ul>
<li><a href="#sqlalchemy.sql.expression.Operators.__and__">Operators.__and__()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.__invert__">Operators.__invert__()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.__or__">Operators.__or__()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.__sa_operate__">Operators.__sa_operate__()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.operate">Operators.operate()</a></li>
<li><a href="#sqlalchemy.sql.expression.Operators.reverse_operate">Operators.reverse_operate()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Over">Over</a><ul>
<li><a href="#sqlalchemy.sql.expression.Over.element">Over.element</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.SQLColumnExpression">SQLColumnExpression</a></li>
<li><a href="#sqlalchemy.sql.expression.TextClause">TextClause</a><ul>
<li><a href="#sqlalchemy.sql.expression.TextClause.bindparams">TextClause.bindparams()</a></li>
<li><a href="#sqlalchemy.sql.expression.TextClause.columns">TextClause.columns()</a></li>
<li><a href="#sqlalchemy.sql.expression.TextClause.self_group">TextClause.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.TryCast">TryCast</a><ul>
<li><a href="#sqlalchemy.sql.expression.TryCast.inherit_cache">TryCast.inherit_cache</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.Tuple">Tuple</a><ul>
<li><a href="#sqlalchemy.sql.expression.Tuple.self_group">Tuple.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a><ul>
<li><a href="#sqlalchemy.sql.expression.WithinGroup.filter">WithinGroup.filter()</a></li>
<li><a href="#sqlalchemy.sql.expression.WithinGroup.over">WithinGroup.over()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.elements.WrapsColumnExpression">WrapsColumnExpression</a></li>
<li><a href="#sqlalchemy.sql.expression.True_">True_</a></li>
<li><a href="#sqlalchemy.sql.expression.TypeCoerce">TypeCoerce</a><ul>
<li><a href="#sqlalchemy.sql.expression.TypeCoerce.self_group">TypeCoerce.self_group()</a></li>
</ul>
</li>
<li><a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a><ul>
<li><a href="#sqlalchemy.sql.expression.UnaryExpression.self_group">UnaryExpression.self_group()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#column-element-typing-utilities">Column Element Typing Utilities</a><ul>
<li><a href="#sqlalchemy.NotNullable">NotNullable()</a></li>
<li><a href="#sqlalchemy.Nullable">Nullable()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
<h1>Column Elements and Expressions<a href="#column-elements-and-expressions">Â¶</a></h1>
<p>The expression API consists of a series of classes each of which represents a specific lexical element within a SQL string. Composed together into a larger structure, they form a statement construct that may be compiled into a string representation that can be passed to a database.
The classes are organized into a hierarchy that begins at the basemost <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a> class. Key subclasses include <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>, which represents the role of any column-based expression in a SQL statement, such as in the columns clause, WHERE clause, and ORDER BY clause, and <a href="selectable.html#sqlalchemy.sql.expression.FromClause">FromClause</a>, which represents the role of a token that is placed in the FROM clause of a SELECT statement.</p>
<h2>Column Element Foundational Constructors<a href="#column-element-foundational-constructors">Â¶</a></h2>
<p>Standalone functions imported from the sqlalchemy namespace which are used when building up SQLAlchemy Expression Language constructs.</p>
<table>
<tr><td><p><a href="#sqlalchemy.sql.expression.and_">and_</a>(*clauses)</p></td>
<td><p>Produce a conjunction of expressions joined by AND.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.bindparam">bindparam</a>(key[, value, type_, unique, ...])</p></td>
<td><p>Produce a âbound expressionâ.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.bitwise_not">bitwise_not</a>(expr)</p></td>
<td><p>Produce a unary bitwise NOT clause, typically via the ~ operator.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.case">case</a>(*whens, [value, else_])</p></td>
<td><p>Produce a CASE expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.cast">cast</a>(expression, type_)</p></td>
<td><p>Produce a CAST expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.column">column</a>(text[, type_, is_literal, _selectable])</p></td>
<td><p>Produce a <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> object.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.custom_op">custom_op</a></p></td>
<td><p>Represent a âcustomâ operator.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.distinct">distinct</a>(expr)</p></td>
<td><p>Produce an column-expression-level unary DISTINCT clause.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.extract">extract</a>(field, expr)</p></td>
<td><p>Return a <a href="#sqlalchemy.sql.expression.Extract">Extract</a> construct.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.false">false</a>()</p></td>
<td><p>Return a <a href="#sqlalchemy.sql.expression.False_">False_</a> construct.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.func">func</a></p></td>
<td><p>Generate SQL function expressions.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.lambda_stmt">lambda_stmt</a>(lmb[, enable_tracking, track_closure_variables, track_on, ...])</p></td>
<td><p>Produce a SQL statement that is cached as a lambda.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.literal">literal</a>(value[, type_, literal_execute])</p></td>
<td><p>Return a literal clause, bound to a bind parameter.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.literal_column">literal_column</a>(text[, type_])</p></td>
<td><p>Produce a <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> object that has the <a href="#sqlalchemy.sql.expression.column.params.is_literal">column.is_literal</a> flag set to True.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.not_">not_</a>(clause)</p></td>
<td><p>Return a negation of the given clause, i.e. NOT(clause).</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.null">null</a>()</p></td>
<td><p>Return a constant <a href="#sqlalchemy.sql.expression.Null">Null</a> construct.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.or_">or_</a>(*clauses)</p></td>
<td><p>Produce a conjunction of expressions joined by OR.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.outparam">outparam</a>(key[, type_])</p></td>
<td><p>Create an âOUTâ parameter for usage in functions (stored procedures), for databases which support them.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.quoted_name">quoted_name</a></p></td>
<td><p>Represent a SQL identifier combined with quoting preferences.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.text">text</a>(text)</p></td>
<td><p>Construct a new <a href="#sqlalchemy.sql.expression.TextClause">TextClause</a> clause, representing a textual SQL string directly.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.true">true</a>()</p></td>
<td><p>Return a constant <a href="#sqlalchemy.sql.expression.True_">True_</a> construct.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.try_cast">try_cast</a>(expression, type_)</p></td>
<td><p>Produce a TRY_CAST expression for backends which support it; this is a CAST which returns NULL for un-castable conversions.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.tuple_">tuple_</a>(*clauses, [types])</p></td>
<td><p>Return a <a href="#sqlalchemy.sql.expression.Tuple">Tuple</a>.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.type_coerce">type_coerce</a>(expression, type_)</p></td>
<td><p>Associate a SQL expression with a particular type, without rendering CAST.</p></td>
</tr>
</table>
<dl>
<dt id="sqlalchemy.sql.expression.and_">
function sqlalchemy.sql.expression.and_(*clauses)<a href="#sqlalchemy.sql.expression.and_">Â¶</a></dt>
<dd><p>Produce a conjunction of expressions joined by AND.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import and_
stmt = select(users_table).where(
and_(
users_table.c.name == 'wendy',
users_table.c.enrolled == True
)
)</pre>
<p>The <a href="#sqlalchemy.sql.expression.and_">and_()</a> conjunction is also available using the Python &amp; operator (though note that compound expressions need to be parenthesized in order to function with Python operator precedence behavior):</p>
<pre>stmt = select(users_table).where(
(users_table.c.name == 'wendy') &amp;
(users_table.c.enrolled == True)
)</pre>
<p>The <a href="#sqlalchemy.sql.expression.and_">and_()</a> operation is also implicit in some cases; the <a href="selectable.html#sqlalchemy.sql.expression.Select.where">Select.where()</a>
method for example can be invoked multiple times against a statement, which will have the effect of each clause being combined using <a href="#sqlalchemy.sql.expression.and_">and_()</a>:</p>
<pre>stmt = select(users_table).\
where(users_table.c.name == 'wendy').\
where(users_table.c.enrolled == True)</pre>
<p>The <a href="#sqlalchemy.sql.expression.and_">and_()</a> construct must be given at least one positional argument in order to be valid; a <a href="#sqlalchemy.sql.expression.and_">and_()</a> construct with no arguments is ambiguous. To produce an âemptyâ or dynamically generated <a href="#sqlalchemy.sql.expression.and_">and_()</a> expression, from a given list of expressions, a âdefaultâ element of <a href="#sqlalchemy.sql.expression.true">true()</a> (or just True) should be specified:</p>
<pre>from sqlalchemy import true
criteria = and_(true(), *expressions)</pre>
<p>The above expression will compile to SQL as the expression true or 1 = 1, depending on backend, if no other expressions are present. If expressions are present, then the <a href="#sqlalchemy.sql.expression.true">true()</a> value is ignored as it does not affect the outcome of an AND expression that has other elements.</p>
<p>Deprecated since version 1.4: The <a href="#sqlalchemy.sql.expression.and_">and_()</a> element now requires that at least one argument is passed; creating the <a href="#sqlalchemy.sql.expression.and_">and_()</a> construct with no arguments is deprecated, and will emit a deprecation warning while continuing to produce a blank SQL string.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.or_">or_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.bindparam">
function sqlalchemy.sql.expression.bindparam(key: str | None, value: Any = _NoArg.NO_ARG, type_: _TypeEngineArgument[_T] | None = None, unique: bool = False, required: bool | Literal[_NoArg.NO_ARG] = _NoArg.NO_ARG, quote: bool | None = None, callable_: Callable[[], Any] | None = None, expanding: bool = False, isoutparam: bool = False, literal_execute: bool = False) â <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a>[_T]<a href="#sqlalchemy.sql.expression.bindparam">Â¶</a></dt>
<dd><p>Produce a âbound expressionâ.</p>
<p>The return value is an instance of <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a>; this is a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
subclass which represents a so-called âplaceholderâ value in a SQL expression, the value of which is supplied at the point at which the statement in executed against a database connection.</p>
<p>In SQLAlchemy, the <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> construct has the ability to carry along the actual value that will be ultimately used at expression time. In this way, it serves not just as a âplaceholderâ for eventual population, but also as a means of representing so-called âunsafeâ values which should not be rendered directly in a SQL statement, but rather should be passed along to the <a href="../glossary.html#term-DBAPI">DBAPI</a> as values which need to be correctly escaped and potentially handled for type-safety.</p>
<p>When using <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> explicitly, the use case is typically one of traditional deferment of parameters; the <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a>
construct accepts a name which can then be referred to at execution time:</p>
<pre>from sqlalchemy import bindparam
stmt = select(users_table).where(
users_table.c.name == bindparam("username")
)</pre>
<p>The above statement, when rendered, will produce SQL similar to:</p>
<pre>SELECT id, name FROM user WHERE name = :username</pre>
<p>In order to populate the value of :username above, the value would typically be applied at execution time to a method like <a href="connections.html#sqlalchemy.engine.Connection.execute">Connection.execute()</a>:</p>
<pre>result = connection.execute(stmt, {"username": "wendy"})</pre>
<p>Explicit use of <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> is also common when producing UPDATE or DELETE statements that are to be invoked multiple times, where the WHERE criterion of the statement is to change on each invocation, such as:</p>
<pre>stmt = (
users_table.update()
.where(user_table.c.name == bindparam("username"))
.values(fullname=bindparam("fullname"))
)
connection.execute(
stmt,
[
{"username": "wendy", "fullname": "Wendy Smith"},
{"username": "jack", "fullname": "Jack Jones"},
],
)</pre>
<p>SQLAlchemyâs Core expression system makes wide use of <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> in an implicit sense. It is typical that Python literal values passed to virtually all SQL expression functions are coerced into fixed <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> constructs. For example, given a comparison operation such as:</p>
<pre>expr = users_table.c.name == 'Wendy'</pre>
<p>The above expression will produce a <a href="#sqlalchemy.sql.expression.BinaryExpression">BinaryExpression</a>
construct, where the left side is the <a href="metadata.html#sqlalchemy.schema.Column">Column</a> object representing the name column, and the right side is a <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> representing the literal value:</p>
<pre>print(repr(expr.right))
BindParameter('%(4327771088 name)s', 'Wendy', type_=String())</pre>
<p>The expression above will render SQL such as:</p>
<pre>user.name = :name_1</pre>
<p>Where the :name_1 parameter name is an anonymous name. The actual string Wendy is not in the rendered string, but is carried along where it is later used within statement execution. If we invoke a statement like the following:</p>
<pre>stmt = select(users_table).where(users_table.c.name == 'Wendy')
result = connection.execute(stmt)</pre>
<p>We would see SQL logging output as:</p>
<pre>SELECT "user".id, "user".name
FROM "user"
WHERE "user".name = %(name_1)s
{'name_1': 'Wendy'}</pre>
<p>Above, we see that Wendy is passed as a parameter to the database, while the placeholder :name_1 is rendered in the appropriate form for the target database, in this case the PostgreSQL database.</p>
<p>Similarly, <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> is invoked automatically when working with <a href="../glossary.html#term-CRUD">CRUD</a> statements as far as the âVALUESâ portion is concerned. The <a href="dml.html#sqlalchemy.sql.expression.insert">insert()</a> construct produces an INSERT expression which will, at statement execution time, generate bound placeholders based on the arguments passed, as in:</p>
<pre>stmt = users_table.insert()
result = connection.execute(stmt, {"name": "Wendy"})</pre>
<p>The above will produce SQL output as:</p>
<pre>INSERT INTO "user" (name) VALUES (%(name)s)
{'name': 'Wendy'}</pre>
<p>The <a href="dml.html#sqlalchemy.sql.expression.Insert">Insert</a> construct, at compilation/execution time, rendered a single <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a>
mirroring the column name name as a result of the single name parameter we passed to the <a href="connections.html#sqlalchemy.engine.Connection.execute">Connection.execute()</a> method.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>key<a href="#sqlalchemy.sql.expression.bindparam.params.key">Â¶</a> â <p>the key (e.g. the name) for this bind param.
Will be used in the generated SQL statement for dialects that use named parameters. This value may be modified when part of a compilation operation, if other <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> objects exist with the same key, or if its length is too long and truncation is required.</p>
<p>If omitted, an âanonymousâ name is generated for the bound parameter; when given a value to bind, the end result is equivalent to calling upon the <a href="#sqlalchemy.sql.expression.literal">literal()</a> function with a value to bind, particularly if the <a href="#sqlalchemy.sql.expression.bindparam.params.unique">bindparam.unique</a> parameter is also provided.</p>
</p></li>
<li><p>value<a href="#sqlalchemy.sql.expression.bindparam.params.value">Â¶</a> â Initial value for this bind param. Will be used at statement execution time as the value for this parameter passed to the DBAPI, if no other value is indicated to the statement execution method for this particular parameter name. Defaults to None.</p></li>
<li><p>callable_<a href="#sqlalchemy.sql.expression.bindparam.params.callable_">Â¶</a> â A callable function that takes the place of âvalueâ. The function will be called at statement execution time to determine the ultimate value. Used for scenarios where the actual bind value cannot be determined at the point at which the clause construct is created, but embedded bind values are still desirable.</p></li>
<li><p>type_<a href="#sqlalchemy.sql.expression.bindparam.params.type_">Â¶</a> â <p>A <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> class or instance representing an optional datatype for this <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a>. If not passed, a type may be determined automatically for the bind, based on the given value; for example, trivial Python types such as str, int, bool may result in the <a href="type_basics.html#sqlalchemy.types.String">String</a>, <a href="type_basics.html#sqlalchemy.types.Integer">Integer</a> or <a href="type_basics.html#sqlalchemy.types.Boolean">Boolean</a> types being automatically selected.</p>
<p>The type of a <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> is significant especially in that the type will apply pre-processing to the value before it is passed to the database. For example, a <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> which refers to a datetime value, and is specified as holding the <a href="type_basics.html#sqlalchemy.types.DateTime">DateTime</a> type, may apply conversion needed to the value (such as stringification on SQLite) before passing the value to the database.</p>
</p></li>
<li><p>unique<a href="#sqlalchemy.sql.expression.bindparam.params.unique">Â¶</a> â if True, the key name of this <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> will be modified if another <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> of the same name already has been located within the containing expression. This flag is used generally by the internals when producing so-called âanonymousâ bound expressions, it isnât generally applicable to explicitly-named <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a>
constructs.</p></li>
<li><p>required<a href="#sqlalchemy.sql.expression.bindparam.params.required">Â¶</a> â If True, a value is required at execution time. If not passed, it defaults to True if neither <a href="#sqlalchemy.sql.expression.bindparam.params.value">bindparam.value</a>
or <a href="#sqlalchemy.sql.expression.bindparam.params.callable">bindparam.callable</a> were passed. If either of these parameters are present, then <a href="#sqlalchemy.sql.expression.bindparam.params.required">bindparam.required</a>
defaults to False.</p></li>
<li><p>quote<a href="#sqlalchemy.sql.expression.bindparam.params.quote">Â¶</a> â True if this parameter name requires quoting and is not currently known as a SQLAlchemy reserved word; this currently only applies to the Oracle backend, where bound names must sometimes be quoted.</p></li>
<li><p>isoutparam<a href="#sqlalchemy.sql.expression.bindparam.params.isoutparam">Â¶</a> â if True, the parameter should be treated like a stored procedure âOUTâ parameter. This applies to backends such as Oracle which support OUT parameters.</p></li>
<li><p>expanding<a href="#sqlalchemy.sql.expression.bindparam.params.expanding">Â¶</a> â <p>if True, this parameter will be treated as an âexpandingâ parameter at execution time; the parameter value is expected to be a sequence, rather than a scalar value, and the string SQL statement will be transformed on a per-execution basis to accommodate the sequence with a variable number of parameter slots passed to the DBAPI.
This is to allow statement caching to be used in conjunction with an IN clause.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a></p>
<p><a href="../orm/extensions/baked.html#baked-in">Using IN expressions</a> - with baked queries</p>
<p>Note</p>
<p>The âexpandingâ feature does not support âexecutemanyâ-
style parameter sets.</p>
<p>New in version 1.2.</p>
<p>Changed in version 1.3: the âexpandingâ bound parameter feature now supports empty lists.</p>
</p></li>
<li><p>literal_execute<a href="#sqlalchemy.sql.expression.bindparam.params.literal_execute">Â¶</a> â <p>if True, the bound parameter will be rendered in the compile phase with a special âPOSTCOMPILEâ token, and the SQLAlchemy compiler will render the final value of the parameter into the SQL statement at statement execution time, omitting the value from the parameter dictionary / list passed to DBAPI cursor.execute(). This produces a similar effect as that of using the literal_binds, compilation flag, however takes place as the statement is sent to the DBAPI cursor.execute() method, rather than when the statement is compiled. The primary use of this capability is for rendering LIMIT / OFFSET clauses for database drivers that canât accommodate for bound parameters in these contexts, while allowing SQL constructs to be cacheable at the compilation level.</p>
<p>New in version 1.4: Added âpost compileâ bound parameters</p>
<p>See also</p>
<p><a href="../changelog/migration_14.html#change-4808">New âpost compileâ bound parameters used for LIMIT/OFFSET in Oracle, SQL Server</a>.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="../tutorial/dbapi_transactions.html#tutorial-sending-parameters">Sending Parameters</a> - in the <a href="../tutorial/index.html#unified-tutorial">SQLAlchemy Unified Tutorial</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.bitwise_not">
function sqlalchemy.sql.expression.bitwise_not(expr: _ColumnExpressionArgument[_T]) â <a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a>[_T]<a href="#sqlalchemy.sql.expression.bitwise_not">Â¶</a></dt>
<dd><p>Produce a unary bitwise NOT clause, typically via the ~ operator.</p>
<p>Not to be confused with boolean negation <a href="#sqlalchemy.sql.expression.not_">not_()</a>.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.case">
function sqlalchemy.sql.expression.case(*whens: typing_Tuple[_ColumnExpressionArgument[bool], Any] | Mapping[Any, Any], value: Any | None = None, else_: Any | None = None) â <a href="#sqlalchemy.sql.expression.Case">Case</a>[Any]<a href="#sqlalchemy.sql.expression.case">Â¶</a></dt>
<dd><p>Produce a CASE expression.</p>
<p>The CASE construct in SQL is a conditional object that acts somewhat analogously to an âif/thenâ construct in other languages. It returns an instance of <a href="#sqlalchemy.sql.expression.Case">Case</a>.</p>
<p><a href="#sqlalchemy.sql.expression.case">case()</a> in its usual form is passed a series of âwhenâ
constructs, that is, a list of conditions and results as tuples:</p>
<pre>from sqlalchemy import case
stmt = select(users_table).\
where(
case(
(users_table.c.name == 'wendy', 'W'),
(users_table.c.name == 'jack', 'J'),
else_='E'
)
)</pre>
<p>The above statement will produce SQL resembling:</p>
<pre>SELECT id, name FROM user
WHERE CASE
WHEN (name = :name_1) THEN :param_1
WHEN (name = :name_2) THEN :param_2
ELSE :param_3
END</pre>
<p>When simple equality expressions of several values against a single parent column are needed, <a href="#sqlalchemy.sql.expression.case">case()</a> also has a âshorthandâ format used via the <a href="#sqlalchemy.sql.expression.case.params.value">case.value</a> parameter, which is passed a column expression to be compared. In this form, the <a href="#sqlalchemy.sql.expression.case.params.whens">case.whens</a>
parameter is passed as a dictionary containing expressions to be compared against keyed to result expressions. The statement below is equivalent to the preceding statement:</p>
<pre>stmt = select(users_table).\
where(
case(
{"wendy": "W", "jack": "J"},
value=users_table.c.name,
else_='E'
)
)</pre>
<p>The values which are accepted as result values in <a href="#sqlalchemy.sql.expression.case.params.whens">case.whens</a> as well as with <a href="#sqlalchemy.sql.expression.case.params.else_">case.else_</a> are coerced from Python literals into <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> constructs.
SQL expressions, e.g. <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> constructs, are accepted as well. To coerce a literal string expression into a constant expression rendered inline, use the <a href="#sqlalchemy.sql.expression.literal_column">literal_column()</a>
construct, as in:</p>
<pre>from sqlalchemy import case, literal_column
case(
(
orderline.c.qty &gt; 100,
literal_column("'greaterthan100'")
),
(
orderline.c.qty &gt; 10,
literal_column("'greaterthan10'")
),
else_=literal_column("'lessthan10'")
)</pre>
<p>The above will render the given constants without using bound parameters for the result values (but still for the comparison values), as in:</p>
<pre>CASE
WHEN (orderline.qty &gt; :qty_1) THEN 'greaterthan100'
WHEN (orderline.qty &gt; :qty_2) THEN 'greaterthan10'
ELSE 'lessthan10'
END</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>*whens<a href="#sqlalchemy.sql.expression.case.params.*whens">Â¶</a> â <p>The criteria to be compared against, <a href="#sqlalchemy.sql.expression.case.params.whens">case.whens</a> accepts two different forms, based on whether or not <a href="#sqlalchemy.sql.expression.case.params.value">case.value</a> is used.</p>
<p>Changed in version 1.4: the <a href="#sqlalchemy.sql.expression.case">case()</a>
function now accepts the series of WHEN conditions positionally</p>
<p>In the first form, it accepts multiple 2-tuples passed as positional arguments; each 2-tuple consists of (&lt;sql expression&gt;, &lt;value&gt;), where the SQL expression is a boolean expression and âvalueâ is a resulting value, e.g.:</p>
<pre>case(
(users_table.c.name == 'wendy', 'W'), (users_table.c.name == 'jack', 'J')
)</pre>
<p>In the second form, it accepts a Python dictionary of comparison values mapped to a resulting value; this form requires <a href="#sqlalchemy.sql.expression.case.params.value">case.value</a> to be present, and values will be compared using the == operator, e.g.:</p>
<pre>case(
{"wendy": "W", "jack": "J"}, value=users_table.c.name )</pre>
</p></li>
<li><p>value<a href="#sqlalchemy.sql.expression.case.params.value">Â¶</a> â An optional SQL expression which will be used as a fixed âcomparison pointâ for candidate values within a dictionary passed to <a href="#sqlalchemy.sql.expression.case.params.whens">case.whens</a>.</p></li>
<li><p>else_<a href="#sqlalchemy.sql.expression.case.params.else_">Â¶</a> â An optional SQL expression which will be the evaluated result of the CASE construct if all expressions within <a href="#sqlalchemy.sql.expression.case.params.whens">case.whens</a> evaluate to false. When omitted, most databases will produce a result of NULL if none of the âwhenâ
expressions evaluate to true.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.cast">
function sqlalchemy.sql.expression.cast(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) â <a href="#sqlalchemy.sql.expression.Cast">Cast</a>[_T]<a href="#sqlalchemy.sql.expression.cast">Â¶</a></dt>
<dd><p>Produce a CAST expression.</p>
<p><a href="#sqlalchemy.sql.expression.cast">cast()</a> returns an instance of <a href="#sqlalchemy.sql.expression.Cast">Cast</a>.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import cast, Numeric
stmt = select(cast(product_table.c.unit_price, Numeric(10, 4)))</pre>
<p>The above statement will produce SQL resembling:</p>
<pre>SELECT CAST(unit_price AS NUMERIC(10, 4)) FROM product</pre>
<p>The <a href="#sqlalchemy.sql.expression.cast">cast()</a> function performs two distinct functions when used. The first is that it renders the CAST expression within the resulting SQL string. The second is that it associates the given type (e.g. <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> class or instance) with the column expression on the Python side, which means the expression will take on the expression operator behavior associated with that type, as well as the bound-value handling and result-row-handling behavior of the type.</p>
<p>An alternative to <a href="#sqlalchemy.sql.expression.cast">cast()</a> is the <a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a> function.
This function performs the second task of associating an expression with a specific type, but does not render the CAST expression in SQL.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>expression<a href="#sqlalchemy.sql.expression.cast.params.expression">Â¶</a> â A SQL expression, such as a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
expression or a Python string which will be coerced into a bound literal value.</p></li>
<li><p>type_<a href="#sqlalchemy.sql.expression.cast.params.type_">Â¶</a> â A <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> class or instance indicating the type to which the CAST should apply.</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="../tutorial/data_select.html#tutorial-casts">Data Casts and Type Coercion</a></p>
<p><a href="#sqlalchemy.sql.expression.try_cast">try_cast()</a> - an alternative to CAST that results in NULLs when the cast fails, instead of raising an error.
Only supported by some dialects.</p>
<p><a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a> - an alternative to CAST that coerces the type on the Python side only, which is often sufficient to generate the correct SQL and data coercion.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.column">
function sqlalchemy.sql.expression.column(text: str, type_: _TypeEngineArgument[_T] | None = None, is_literal: bool = False, _selectable: <a href="selectable.html#sqlalchemy.sql.expression.FromClause">FromClause</a> | None = None) â <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a>[_T]<a href="#sqlalchemy.sql.expression.column">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> object.</p>
<p>The <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> is a lightweight analogue to the <a href="metadata.html#sqlalchemy.schema.Column">Column</a> class. The <a href="#sqlalchemy.sql.expression.column">column()</a>
function can be invoked with just a name alone, as in:</p>
<pre>from sqlalchemy import column
id, name = column("id"), column("name")
stmt = select(id, name).select_from("user")</pre>
<p>The above statement would produce SQL like:</p>
<pre>SELECT id, name FROM user</pre>
<p>Once constructed, <a href="#sqlalchemy.sql.expression.column">column()</a>
may be used like any other SQL expression element such as within <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
constructs:</p>
<pre>from sqlalchemy.sql import column
id, name = column("id"), column("name")
stmt = select(id, name).select_from("user")</pre>
<p>The text handled by <a href="#sqlalchemy.sql.expression.column">column()</a>
is assumed to be handled like the name of a database column; if the string contains mixed case, special characters, or matches a known reserved word on the target backend, the column expression will render using the quoting behavior determined by the backend. To produce a textual SQL expression that is rendered exactly without any quoting, use <a href="#sqlalchemy.sql.expression.literal_column">literal_column()</a> instead, or pass True as the value of <a href="#sqlalchemy.sql.expression.column.params.is_literal">column.is_literal</a>. Additionally, full SQL statements are best handled using the <a href="#sqlalchemy.sql.expression.text">text()</a>
construct.</p>
<p><a href="#sqlalchemy.sql.expression.column">column()</a> can be used in a table-like fashion by combining it with the <a href="selectable.html#sqlalchemy.sql.expression.table">table()</a> function (which is the lightweight analogue to <a href="metadata.html#sqlalchemy.schema.Table">Table</a>
) to produce a working table construct with minimal boilerplate:</p>
<pre>from sqlalchemy import table, column, select
user = table("user",
column("id"),
column("name"),
column("description"),
)
stmt = select(user.c.description).where(user.c.name == 'wendy')</pre>
<p>A <a href="#sqlalchemy.sql.expression.column">column()</a> / <a href="selectable.html#sqlalchemy.sql.expression.table">table()</a>
construct like that illustrated above can be created in an ad-hoc fashion and is not associated with any <a href="metadata.html#sqlalchemy.schema.MetaData">MetaData</a>, DDL, or events, unlike its <a href="metadata.html#sqlalchemy.schema.Table">Table</a> counterpart.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>text<a href="#sqlalchemy.sql.expression.column.params.text">Â¶</a> â the text of the element.</p></li>
<li><p>type<a href="#sqlalchemy.sql.expression.column.params.type">Â¶</a> â <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> object which can associate this <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> with a type.</p></li>
<li><p>is_literal<a href="#sqlalchemy.sql.expression.column.params.is_literal">Â¶</a> â if True, the <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> is assumed to be an exact expression that will be delivered to the output with no quoting rules applied regardless of case sensitive settings. the <a href="#sqlalchemy.sql.expression.literal_column">literal_column()</a> function essentially invokes <a href="#sqlalchemy.sql.expression.column">column()</a> while passing is_literal=True.</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="metadata.html#sqlalchemy.schema.Column">Column</a></p>
<p><a href="#sqlalchemy.sql.expression.literal_column">literal_column()</a></p>
<p><a href="selectable.html#sqlalchemy.sql.expression.table">table()</a></p>
<p><a href="#sqlalchemy.sql.expression.text">text()</a></p>
<p><a href="../tutorial/data_select.html#tutorial-select-arbitrary-text">Selecting with Textual Column Expressions</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.custom_op">
class sqlalchemy.sql.expression.custom_op<a href="#sqlalchemy.sql.expression.custom_op">Â¶</a></dt>
<dd><p>Represent a âcustomâ operator.</p>
<p><a href="#sqlalchemy.sql.expression.custom_op">custom_op</a> is normally instantiated when the <a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a> or <a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a> methods are used to create a custom operator callable. The class can also be used directly when programmatically constructing expressions. E.g.
to represent the âfactorialâ operation:</p>
<pre>from sqlalchemy.sql import UnaryExpression
from sqlalchemy.sql import operators
from sqlalchemy import Numeric
unary = UnaryExpression(table.c.somecolumn,
modifier=operators.custom_op("!"),
type_=Numeric)</pre>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a></p>
<p><a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.custom_op">sqlalchemy.sql.expression.custom_op</a> (sqlalchemy.sql.expression.OperatorType, typing.Generic)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.distinct">
function sqlalchemy.sql.expression.distinct(expr: _ColumnExpressionArgument[_T]) â <a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a>[_T]<a href="#sqlalchemy.sql.expression.distinct">Â¶</a></dt>
<dd><p>Produce an column-expression-level unary DISTINCT clause.</p>
<p>This applies the DISTINCT keyword to an individual column expression (e.g. not the whole statement), and renders specifically in that column position; this is used for containment within an aggregate function, as in:</p>
<pre>from sqlalchemy import distinct, func
stmt = select(users_table.c.id, func.count(distinct(users_table.c.name)))</pre>
<p>The above would produce an statement resembling:</p>
<pre>SELECT user.id, count(DISTINCT user.name) FROM user</pre>
<p>Tip</p>
<p>The <a href="#sqlalchemy.sql.expression.distinct">distinct()</a> function does not apply DISTINCT to the full SELECT statement, instead applying a DISTINCT modifier to individual column expressions. For general SELECT DISTINCT support, use the <a href="selectable.html#sqlalchemy.sql.expression.Select.distinct">Select.distinct()</a> method on <a href="selectable.html#sqlalchemy.sql.expression.Select">Select</a>.</p>
<p>The <a href="#sqlalchemy.sql.expression.distinct">distinct()</a> function is also available as a column-level method, e.g. <a href="#sqlalchemy.sql.expression.ColumnElement.distinct">ColumnElement.distinct()</a>, as in:</p>
<pre>stmt = select(func.count(users_table.c.name.distinct()))</pre>
<p>The <a href="#sqlalchemy.sql.expression.distinct">distinct()</a> operator is different from the <a href="selectable.html#sqlalchemy.sql.expression.Select.distinct">Select.distinct()</a> method of <a href="selectable.html#sqlalchemy.sql.expression.Select">Select</a>, which produces a SELECT statement with DISTINCT applied to the result set as a whole, e.g. a SELECT DISTINCT expression. See that method for further information.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnElement.distinct">ColumnElement.distinct()</a></p>
<p><a href="selectable.html#sqlalchemy.sql.expression.Select.distinct">Select.distinct()</a></p>
<p><a href="#sqlalchemy.sql.expression.func">func</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.extract">
function sqlalchemy.sql.expression.extract(field: str, expr: _ColumnExpressionArgument[Any]) â <a href="#sqlalchemy.sql.expression.Extract">Extract</a><a href="#sqlalchemy.sql.expression.extract">Â¶</a></dt>
<dd><p>Return a <a href="#sqlalchemy.sql.expression.Extract">Extract</a> construct.</p>
<p>This is typically available as <a href="#sqlalchemy.sql.expression.extract">extract()</a>
as well as func.extract from the <a href="#sqlalchemy.sql.expression.func">func</a> namespace.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>field<a href="#sqlalchemy.sql.expression.extract.params.field">Â¶</a> â The field to extract.</p></li>
<li><p>expr<a href="#sqlalchemy.sql.expression.extract.params.expr">Â¶</a> â A column or Python scalar expression serving as the right side of the EXTRACT expression.</p></li>
</ul>
</dd>
</dl>
<p>E.g.:</p>
<pre>from sqlalchemy import extract
from sqlalchemy import table, column
logged_table = table("user",
column("id"),
column("date_created"),
)
stmt = select(logged_table.c.id).where(
extract("YEAR", logged_table.c.date_created) == 2021
)</pre>
<p>In the above example, the statement is used to select ids from the database where the YEAR component matches a specific value.</p>
<p>Similarly, one can also select an extracted component:</p>
<pre>stmt = select(
extract("YEAR", logged_table.c.date_created)
).where(logged_table.c.id == 1)</pre>
<p>The implementation of EXTRACT may vary across database backends.
Users are reminded to consult their database documentation.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.false">
function sqlalchemy.sql.expression.false() â <a href="#sqlalchemy.sql.expression.False_">False_</a><a href="#sqlalchemy.sql.expression.false">Â¶</a></dt>
<dd><p>Return a <a href="#sqlalchemy.sql.expression.False_">False_</a> construct.</p>
<p>E.g.:</p>
<pre>&gt;&gt;&gt; from sqlalchemy import false
&gt;&gt;&gt; print(select(t.c.x).where(false()))
SELECT x FROM t WHERE false
</pre>
<p>A backend which does not support true/false constants will render as an expression against 1 or 0:</p>
<pre>&gt;&gt;&gt; print(select(t.c.x).where(false()))
SELECT x FROM t WHERE 0 = 1
</pre>
<p>The <a href="#sqlalchemy.sql.expression.true">true()</a> and <a href="#sqlalchemy.sql.expression.false">false()</a> constants also feature âshort circuitâ operation within an <a href="#sqlalchemy.sql.expression.and_">and_()</a> or <a href="#sqlalchemy.sql.expression.or_">or_()</a>
conjunction:</p>
<pre>&gt;&gt;&gt; print(select(t.c.x).where(or_(t.c.x &gt; 5, true())))
SELECT x FROM t WHERE true
&gt;&gt;&gt; print(select(t.c.x).where(and_(t.c.x &gt; 5, false())))
SELECT x FROM t WHERE false
</pre>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.true">true()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.func">
sqlalchemy.sql.expression.func = &lt;sqlalchemy.sql.functions._FunctionGenerator object&gt;<a href="#sqlalchemy.sql.expression.func">Â¶</a></dt>
<dd><p>Generate SQL function expressions.</p>
<p><a href="#sqlalchemy.sql.expression.func">func</a> is a special object instance which generates SQL functions based on name-based attributes, e.g.:</p>
<pre>&gt;&gt;&gt; print(func.count(1))
count(:param_1)
</pre>
<p>The returned object is an instance of <a href="functions.html#sqlalchemy.sql.functions.Function">Function</a>, and is a column-oriented SQL element like any other, and is used in that way:</p>
<pre>&gt;&gt;&gt; print(select(func.count(table.c.id)))
SELECT count(sometable.id) FROM sometable
</pre>
<p>Any name can be given to <a href="#sqlalchemy.sql.expression.func">func</a>. If the function name is unknown to SQLAlchemy, it will be rendered exactly as is. For common SQL functions which SQLAlchemy is aware of, the name may be interpreted as a generic function which will be compiled appropriately to the target database:</p>
<pre>&gt;&gt;&gt; print(func.current_timestamp())
CURRENT_TIMESTAMP
</pre>
<p>To call functions which are present in dot-separated packages, specify them in the same manner:</p>
<pre>&gt;&gt;&gt; print(func.stats.yield_curve(5, 10))
stats.yield_curve(:yield_curve_1, :yield_curve_2)
</pre>
<p>SQLAlchemy can be made aware of the return type of functions to enable type-specific lexical and result-based behavior. For example, to ensure that a string-based function returns a Unicode value and is similarly treated as a string in expressions, specify <a href="type_basics.html#sqlalchemy.types.Unicode">Unicode</a> as the type:</p>
<pre>&gt;&gt;&gt; print(func.my_string(u'hi', type_=Unicode) + ' ' +
... func.my_string(u'there', type_=Unicode))
my_string(:my_string_1) || :my_string_2 || my_string(:my_string_3)
</pre>
<p>The object returned by a <a href="#sqlalchemy.sql.expression.func">func</a> call is usually an instance of <a href="functions.html#sqlalchemy.sql.functions.Function">Function</a>.
This object meets the âcolumnâ interface, including comparison and labeling functions. The object can also be passed the Connectable.execute()
method of a <a href="connections.html#sqlalchemy.engine.Connection">Connection</a> or <a href="connections.html#sqlalchemy.engine.Engine">Engine</a>, where it will be wrapped inside of a SELECT statement first:</p>
<pre>print(connection.execute(func.current_timestamp()).scalar())</pre>
<p>In a few exception cases, the <a href="#sqlalchemy.sql.expression.func">func</a> accessor will redirect a name to a built-in expression such as <a href="#sqlalchemy.sql.expression.cast">cast()</a>
or <a href="#sqlalchemy.sql.expression.extract">extract()</a>, as these names have well-known meaning but are not exactly the same as âfunctionsâ from a SQLAlchemy perspective.</p>
<p>Functions which are interpreted as âgenericâ functions know how to calculate their return type automatically. For a listing of known generic functions, see <a href="functions.html#generic-functions">SQL and Generic Functions</a>.</p>
<p>Note</p>
<p>The <a href="#sqlalchemy.sql.expression.func">func</a> construct has only limited support for calling standalone âstored proceduresâ, especially those with special parameterization concerns.</p>
<p>See the section <a href="connections.html#stored-procedures">Calling Stored Procedures and User Defined Functions</a> for details on how to use the DBAPI-level callproc() method for fully traditional stored procedures.</p>
<p>See also</p>
<p><a href="../tutorial/data_select.html#tutorial-functions">Working with SQL Functions</a> - in the <a href="../tutorial/index.html#unified-tutorial">SQLAlchemy Unified Tutorial</a></p>
<p><a href="functions.html#sqlalchemy.sql.functions.Function">Function</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.lambda_stmt">
function sqlalchemy.sql.expression.lambda_stmt(lmb: Callable[[], Any], enable_tracking: bool = True, track_closure_variables: bool = True, track_on: object | None = None, global_track_bound_values: bool = True, track_bound_values: bool = True, lambda_cache: MutableMapping[Tuple[Any, ...], NonAnalyzedFunction | AnalyzedFunction] | None = None) â <a href="foundation.html#sqlalchemy.sql.expression.StatementLambdaElement">StatementLambdaElement</a><a href="#sqlalchemy.sql.expression.lambda_stmt">Â¶</a></dt>
<dd><p>Produce a SQL statement that is cached as a lambda.</p>
<p>The Python code object within the lambda is scanned for both Python literals that will become bound parameters as well as closure variables that refer to Core or ORM constructs that may vary. The lambda itself will be invoked only once per particular set of constructs detected.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import lambda_stmt
stmt = lambda_stmt(lambda: table.select())
stmt += lambda s: s.where(table.c.id == 5)
result = connection.execute(stmt)</pre>
<p>The object returned is an instance of <a href="foundation.html#sqlalchemy.sql.expression.StatementLambdaElement">StatementLambdaElement</a>.</p>
<p>New in version 1.4.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>lmb<a href="#sqlalchemy.sql.expression.lambda_stmt.params.lmb">Â¶</a> â a Python function, typically a lambda, which takes no arguments and returns a SQL expression construct</p></li>
<li><p>enable_tracking<a href="#sqlalchemy.sql.expression.lambda_stmt.params.enable_tracking">Â¶</a> â when False, all scanning of the given lambda for changes in closure variables or bound parameters is disabled. Use for a lambda that produces the identical results in all cases with no parameterization.</p></li>
<li><p>track_closure_variables<a href="#sqlalchemy.sql.expression.lambda_stmt.params.track_closure_variables">Â¶</a> â when False, changes in closure variables within the lambda will not be scanned. Use for a lambda where the state of its closure variables will never change the SQL structure returned by the lambda.</p></li>
<li><p>track_bound_values<a href="#sqlalchemy.sql.expression.lambda_stmt.params.track_bound_values">Â¶</a> â when False, bound parameter tracking will be disabled for the given lambda. Use for a lambda that either does not produce any bound values, or where the initial bound values never change.</p></li>
<li><p>global_track_bound_values<a href="#sqlalchemy.sql.expression.lambda_stmt.params.global_track_bound_values">Â¶</a> â when False, bound parameter tracking will be disabled for the entire statement including additional links added via the <a href="foundation.html#sqlalchemy.sql.expression.StatementLambdaElement.add_criteria">StatementLambdaElement.add_criteria()</a> method.</p></li>
<li><p>lambda_cache<a href="#sqlalchemy.sql.expression.lambda_stmt.params.lambda_cache">Â¶</a> â a dictionary or other mapping-like object where information about the lambdaâs Python code as well as the tracked closure variables in the lambda itself will be stored. Defaults to a global LRU cache. This cache is independent of the âcompiled_cacheâ
used by the <a href="connections.html#sqlalchemy.engine.Connection">Connection</a> object.</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="connections.html#engine-lambda-caching">Using Lambdas to add significant speed gains to statement production</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.literal">
function sqlalchemy.sql.expression.literal(value: Any, type_: _TypeEngineArgument[Any] | None = None, literal_execute: bool = False) â <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a>[Any]<a href="#sqlalchemy.sql.expression.literal">Â¶</a></dt>
<dd><p>Return a literal clause, bound to a bind parameter.</p>
<p>Literal clauses are created automatically when non-
<a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a> objects (such as strings, ints, dates, etc.) are used in a comparison operation with a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
subclass, such as a <a href="metadata.html#sqlalchemy.schema.Column">Column</a> object. Use this function to force the generation of a literal clause, which will be created as a <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> with a bound value.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>value<a href="#sqlalchemy.sql.expression.literal.params.value">Â¶</a> â the value to be bound. Can be any Python object supported by the underlying DB-API, or is translatable via the given type argument.</p></li>
<li><p>type_<a href="#sqlalchemy.sql.expression.literal.params.type_">Â¶</a> â an optional <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> which will provide bind-parameter translation for this literal.</p></li>
<li><p>literal_execute<a href="#sqlalchemy.sql.expression.literal.params.literal_execute">Â¶</a> â <p>optional bool, when True, the SQL engine will attempt to render the bound value directly in the SQL statement at execution time rather than providing as a parameter value.</p>
<p>New in version 2.0.</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.literal_column">
function sqlalchemy.sql.expression.literal_column(text: str, type_: _TypeEngineArgument[_T] | None = None) â <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a>[_T]<a href="#sqlalchemy.sql.expression.literal_column">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> object that has the <a href="#sqlalchemy.sql.expression.column.params.is_literal">column.is_literal</a> flag set to True.</p>
<p><a href="#sqlalchemy.sql.expression.literal_column">literal_column()</a> is similar to <a href="#sqlalchemy.sql.expression.column">column()</a>, except that it is more often used as a âstandaloneâ column expression that renders exactly as stated; while <a href="#sqlalchemy.sql.expression.column">column()</a>
stores a string name that will be assumed to be part of a table and may be quoted as such, <a href="#sqlalchemy.sql.expression.literal_column">literal_column()</a> can be that, or any other arbitrary column-oriented expression.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>text<a href="#sqlalchemy.sql.expression.literal_column.params.text">Â¶</a> â the text of the expression; can be any SQL expression.
Quoting rules will not be applied. To specify a column-name expression which should be subject to quoting rules, use the <a href="#sqlalchemy.sql.expression.column">column()</a>
function.</p></li>
<li><p>type_<a href="#sqlalchemy.sql.expression.literal_column.params.type_">Â¶</a> â an optional <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>
object which will provide result-set translation and additional expression semantics for this column. If left as None the type will be <a href="type_api.html#sqlalchemy.types.NullType">NullType</a>.</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.column">column()</a></p>
<p><a href="#sqlalchemy.sql.expression.text">text()</a></p>
<p><a href="../tutorial/data_select.html#tutorial-select-arbitrary-text">Selecting with Textual Column Expressions</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.not_">
function sqlalchemy.sql.expression.not_(clause: _ColumnExpressionArgument[_T]) â <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>[_T]<a href="#sqlalchemy.sql.expression.not_">Â¶</a></dt>
<dd><p>Return a negation of the given clause, i.e. NOT(clause).</p>
<p>The ~ operator is also overloaded on all <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> subclasses to produce the same result.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.null">
function sqlalchemy.sql.expression.null() â <a href="#sqlalchemy.sql.expression.Null">Null</a><a href="#sqlalchemy.sql.expression.null">Â¶</a></dt>
<dd><p>Return a constant <a href="#sqlalchemy.sql.expression.Null">Null</a> construct.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.or_">
function sqlalchemy.sql.expression.or_(*clauses)<a href="#sqlalchemy.sql.expression.or_">Â¶</a></dt>
<dd><p>Produce a conjunction of expressions joined by OR.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import or_
stmt = select(users_table).where(
or_(
users_table.c.name == 'wendy',
users_table.c.name == 'jack'
)
)</pre>
<p>The <a href="#sqlalchemy.sql.expression.or_">or_()</a> conjunction is also available using the Python | operator (though note that compound expressions need to be parenthesized in order to function with Python operator precedence behavior):</p>
<pre>stmt = select(users_table).where(
(users_table.c.name == 'wendy') |
(users_table.c.name == 'jack')
)</pre>
<p>The <a href="#sqlalchemy.sql.expression.or_">or_()</a> construct must be given at least one positional argument in order to be valid; a <a href="#sqlalchemy.sql.expression.or_">or_()</a> construct with no arguments is ambiguous. To produce an âemptyâ or dynamically generated <a href="#sqlalchemy.sql.expression.or_">or_()</a> expression, from a given list of expressions, a âdefaultâ element of <a href="#sqlalchemy.sql.expression.false">false()</a> (or just False) should be specified:</p>
<pre>from sqlalchemy import false
or_criteria = or_(false(), *expressions)</pre>
<p>The above expression will compile to SQL as the expression false or 0 = 1, depending on backend, if no other expressions are present. If expressions are present, then the <a href="#sqlalchemy.sql.expression.false">false()</a> value is ignored as it does not affect the outcome of an OR expression which has other elements.</p>
<p>Deprecated since version 1.4: The <a href="#sqlalchemy.sql.expression.or_">or_()</a> element now requires that at least one argument is passed; creating the <a href="#sqlalchemy.sql.expression.or_">or_()</a> construct with no arguments is deprecated, and will emit a deprecation warning while continuing to produce a blank SQL string.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.and_">and_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.outparam">
function sqlalchemy.sql.expression.outparam(key: str, type_: <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>[_T] | None = None) â <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a>[_T]<a href="#sqlalchemy.sql.expression.outparam">Â¶</a></dt>
<dd><p>Create an âOUTâ parameter for usage in functions (stored procedures), for databases which support them.</p>
<p>The outparam can be used like a regular function parameter.
The âoutputâ value will be available from the <a href="connections.html#sqlalchemy.engine.CursorResult">CursorResult</a> object via its out_parameters attribute, which returns a dictionary containing the values.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.text">
function sqlalchemy.sql.expression.text(text: str) â <a href="#sqlalchemy.sql.expression.TextClause">TextClause</a><a href="#sqlalchemy.sql.expression.text">Â¶</a></dt>
<dd><p>Construct a new <a href="#sqlalchemy.sql.expression.TextClause">TextClause</a> clause, representing a textual SQL string directly.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import text
t = text("SELECT * FROM users")
result = connection.execute(t)</pre>
<p>The advantages <a href="#sqlalchemy.sql.expression.text">text()</a>
provides over a plain string are backend-neutral support for bind parameters, per-statement execution options, as well as bind parameter and result-column typing behavior, allowing SQLAlchemy type constructs to play a role when executing a statement that is specified literally. The construct can also be provided with a .c collection of column elements, allowing it to be embedded in other SQL expression constructs as a subquery.</p>
<p>Bind parameters are specified by name, using the format :name.
E.g.:</p>
<pre>t = text("SELECT * FROM users WHERE id=:user_id")
result = connection.execute(t, {"user_id": 12})</pre>
<p>For SQL statements where a colon is required verbatim, as within an inline string, use a backslash to escape:</p>
<pre>t = text(r"SELECT * FROM users WHERE name='\:username'")</pre>
<p>The <a href="#sqlalchemy.sql.expression.TextClause">TextClause</a>
construct includes methods which can provide information about the bound parameters as well as the column values which would be returned from the textual statement, assuming itâs an executable SELECT type of statement. The <a href="#sqlalchemy.sql.expression.TextClause.bindparams">TextClause.bindparams()</a>
method is used to provide bound parameter detail, and <a href="#sqlalchemy.sql.expression.TextClause.columns">TextClause.columns()</a>
method allows specification of return columns including names and types:</p>
<pre>t = text("SELECT * FROM users WHERE id=:user_id").\
bindparams(user_id=7).\
columns(id=Integer, name=String)
for id, name in connection.execute(t):
print(id, name)</pre>
<p>The <a href="#sqlalchemy.sql.expression.text">text()</a> construct is used in cases when a literal string SQL fragment is specified as part of a larger query, such as for the WHERE clause of a SELECT statement:</p>
<pre>s = select(users.c.id, users.c.name).where(text("id=:user_id"))
result = connection.execute(s, {"user_id": 12})</pre>
<p><a href="#sqlalchemy.sql.expression.text">text()</a> is also used for the construction of a full, standalone statement using plain text.
As such, SQLAlchemy refers to it as an <a href="selectable.html#sqlalchemy.sql.expression.Executable">Executable</a> object and may be used like any other statement passed to an .execute() method.</p>
<dl>
<dt>Parameters:</dt>
<dd><p>text<a href="#sqlalchemy.sql.expression.text.params.text">Â¶</a> â <p>the text of the SQL statement to be created. Use :&lt;param&gt;
to specify bind parameters; they will be compiled to their engine-specific format.</p>
<p>Warning</p>
<p>The <a href="#sqlalchemy.sql.expression.text.params.text">text.text</a> argument to <a href="#sqlalchemy.sql.expression.text">text()</a> can be passed as a Python string argument, which will be treated as trusted SQL text and rendered as given. DO NOT PASS UNTRUSTED INPUT TO THIS PARAMETER.</p>
</p>
</dd>
</dl>
<p>See also</p>
<p><a href="../tutorial/data_select.html#tutorial-select-arbitrary-text">Selecting with Textual Column Expressions</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.true">
function sqlalchemy.sql.expression.true() â <a href="#sqlalchemy.sql.expression.True_">True_</a><a href="#sqlalchemy.sql.expression.true">Â¶</a></dt>
<dd><p>Return a constant <a href="#sqlalchemy.sql.expression.True_">True_</a> construct.</p>
<p>E.g.:</p>
<pre>&gt;&gt;&gt; from sqlalchemy import true
&gt;&gt;&gt; print(select(t.c.x).where(true()))
SELECT x FROM t WHERE true
</pre>
<p>A backend which does not support true/false constants will render as an expression against 1 or 0:</p>
<pre>&gt;&gt;&gt; print(select(t.c.x).where(true()))
SELECT x FROM t WHERE 1 = 1
</pre>
<p>The <a href="#sqlalchemy.sql.expression.true">true()</a> and <a href="#sqlalchemy.sql.expression.false">false()</a> constants also feature âshort circuitâ operation within an <a href="#sqlalchemy.sql.expression.and_">and_()</a> or <a href="#sqlalchemy.sql.expression.or_">or_()</a>
conjunction:</p>
<pre>&gt;&gt;&gt; print(select(t.c.x).where(or_(t.c.x &gt; 5, true())))
SELECT x FROM t WHERE true
&gt;&gt;&gt; print(select(t.c.x).where(and_(t.c.x &gt; 5, false())))
SELECT x FROM t WHERE false
</pre>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.false">false()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.try_cast">
function sqlalchemy.sql.expression.try_cast(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) â <a href="#sqlalchemy.sql.expression.TryCast">TryCast</a>[_T]<a href="#sqlalchemy.sql.expression.try_cast">Â¶</a></dt>
<dd><p>Produce a TRY_CAST expression for backends which support it; this is a CAST which returns NULL for un-castable conversions.</p>
<p>In SQLAlchemy, this construct is supported only by the SQL Server dialect, and will raise a <a href="exceptions.html#sqlalchemy.exc.CompileError">CompileError</a> if used on other included backends. However, third party backends may also support this construct.</p>
<p>Tip</p>
<p>As <a href="#sqlalchemy.sql.expression.try_cast">try_cast()</a> originates from the SQL Server dialect, itâs importable both from sqlalchemy. as well as from sqlalchemy.dialects.mssql.</p>
<p><a href="#sqlalchemy.sql.expression.try_cast">try_cast()</a> returns an instance of <a href="#sqlalchemy.sql.expression.TryCast">TryCast</a> and generally behaves similarly to the <a href="#sqlalchemy.sql.expression.Cast">Cast</a> construct; at the SQL level, the difference between CAST and TRY_CAST is that TRY_CAST returns NULL for an un-castable expression, such as attempting to cast a string "hi" to an integer value.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import select, try_cast, Numeric
stmt = select(
try_cast(product_table.c.unit_price, Numeric(10, 4))
)</pre>
<p>The above would render on Microsoft SQL Server as:</p>
<pre>SELECT TRY_CAST (product_table.unit_price AS NUMERIC(10, 4))
FROM product_table</pre>
<p>New in version 2.0.14: <a href="#sqlalchemy.sql.expression.try_cast">try_cast()</a> has been generalized from the SQL Server dialect into a general use construct that may be supported by additional dialects.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.tuple_">
function sqlalchemy.sql.expression.tuple_(*clauses: _ColumnExpressionArgument[Any], types: <a href="defaults.html#sqlalchemy.schema.Sequence">Sequence</a>[_TypeEngineArgument[Any]] | None = None) â <a href="#sqlalchemy.sql.expression.Tuple">Tuple</a><a href="#sqlalchemy.sql.expression.tuple_">Â¶</a></dt>
<dd><p>Return a <a href="#sqlalchemy.sql.expression.Tuple">Tuple</a>.</p>
<p>Main usage is to produce a composite IN construct using <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a></p>
<pre>from sqlalchemy import tuple_
tuple_(table.c.col1, table.c.col2).in_(
[(1, 2), (5, 12), (10, 19)]
)</pre>
<p>Changed in version 1.3.6: Added support for SQLite IN tuples.</p>
<p>Warning</p>
<p>The composite IN construct is not supported by all backends, and is currently known to work on PostgreSQL, MySQL, and SQLite.
Unsupported backends will raise a subclass of <a href="exceptions.html#sqlalchemy.exc.DBAPIError">DBAPIError</a> when such an expression is invoked.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.type_coerce">
function sqlalchemy.sql.expression.type_coerce(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) â <a href="#sqlalchemy.sql.expression.TypeCoerce">TypeCoerce</a>[_T]<a href="#sqlalchemy.sql.expression.type_coerce">Â¶</a></dt>
<dd><p>Associate a SQL expression with a particular type, without rendering CAST.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import type_coerce
stmt = select(type_coerce(log_table.date_string, StringDateTime()))</pre>
<p>The above construct will produce a <a href="#sqlalchemy.sql.expression.TypeCoerce">TypeCoerce</a> object, which does not modify the rendering in any way on the SQL side, with the possible exception of a generated label if used in a columns clause context:</p>
<pre>SELECT date_string AS date_string FROM log</pre>
<p>When result rows are fetched, the StringDateTime type processor will be applied to result rows on behalf of the date_string column.</p>
<p>Note</p>
<p>the <a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a> construct does not render any SQL syntax of its own, including that it does not imply parenthesization. Please use <a href="#sqlalchemy.sql.expression.TypeCoerce.self_group">TypeCoerce.self_group()</a>
if explicit parenthesization is required.</p>
<p>In order to provide a named label for the expression, use <a href="#sqlalchemy.sql.expression.ColumnElement.label">ColumnElement.label()</a>:</p>
<pre>stmt = select(
type_coerce(log_table.date_string, StringDateTime()).label('date')
)</pre>
<p>A type that features bound-value handling will also have that behavior take effect when literal values or <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> constructs are passed to <a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a> as targets.
For example, if a type implements the <a href="type_api.html#sqlalchemy.types.TypeEngine.bind_expression">TypeEngine.bind_expression()</a>
method or <a href="type_api.html#sqlalchemy.types.TypeEngine.bind_processor">TypeEngine.bind_processor()</a> method or equivalent, these functions will take effect at statement compilation/execution time when a literal value is passed, as in:</p>
<pre># bound-value handling of MyStringType will be applied to the
# literal value "some string"
stmt = select(type_coerce("some string", MyStringType))</pre>
<p>When using <a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a> with composed expressions, note that parenthesis are not applied. If <a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a> is being used in an operator context where the parenthesis normally present from CAST are necessary, use the <a href="#sqlalchemy.sql.expression.TypeCoerce.self_group">TypeCoerce.self_group()</a> method:</p>
<pre>&gt;&gt;&gt; some_integer = column("someint", Integer)
&gt;&gt;&gt; some_string = column("somestr", String)
&gt;&gt;&gt; expr = type_coerce(some_integer + 5, String) + some_string
&gt;&gt;&gt; print(expr)
someint + :someint_1 || somestr
&gt;&gt;&gt; expr = type_coerce(some_integer + 5, String).self_group() + some_string
&gt;&gt;&gt; print(expr)
(someint + :someint_1) || somestr
</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>expression<a href="#sqlalchemy.sql.expression.type_coerce.params.expression">Â¶</a> â A SQL expression, such as a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
expression or a Python string which will be coerced into a bound literal value.</p></li>
<li><p>type_<a href="#sqlalchemy.sql.expression.type_coerce.params.type_">Â¶</a> â A <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> class or instance indicating the type to which the expression is coerced.</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="../tutorial/data_select.html#tutorial-casts">Data Casts and Type Coercion</a></p>
<p><a href="#sqlalchemy.sql.expression.cast">cast()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.quoted_name">
class sqlalchemy.sql.expression.quoted_name<a href="#sqlalchemy.sql.expression.quoted_name">Â¶</a></dt>
<dd><p>Represent a SQL identifier combined with quoting preferences.</p>
<p><a href="#sqlalchemy.sql.expression.quoted_name">quoted_name</a> is a Python unicode/str subclass which represents a particular identifier name along with a quote flag. This quote flag, when set to True or False, overrides automatic quoting behavior for this identifier in order to either unconditionally quote or to not quote the name. If left at its default of None, quoting behavior is applied to the identifier on a per-backend basis based on an examination of the token itself.</p>
<p>A <a href="#sqlalchemy.sql.expression.quoted_name">quoted_name</a> object with quote=True is also prevented from being modified in the case of a so-called âname normalizeâ option. Certain database backends, such as Oracle, Firebird, and DB2 ânormalizeâ case-insensitive names as uppercase. The SQLAlchemy dialects for these backends convert from SQLAlchemyâs lower-case-means-insensitive convention to the upper-case-means-insensitive conventions of those backends.
The quote=True flag here will prevent this conversion from occurring to support an identifier thatâs quoted as all lower case against such a backend.</p>
<p>The <a href="#sqlalchemy.sql.expression.quoted_name">quoted_name</a> object is normally created automatically when specifying the name for key schema constructs such as <a href="metadata.html#sqlalchemy.schema.Table">Table</a>, <a href="metadata.html#sqlalchemy.schema.Column">Column</a>, and others.
The class can also be passed explicitly as the name to any function that receives a name which can be quoted. Such as to use the Engine.has_table()
method with an unconditionally quoted name:</p>
<pre>from sqlalchemy import create_engine
from sqlalchemy import inspect
from sqlalchemy.sql import quoted_name
engine = create_engine("oracle+cx_oracle://some_dsn")
print(inspect(engine).has_table(quoted_name("some_table", True)))</pre>
<p>The above logic will run the âhas tableâ logic against the Oracle backend, passing the name exactly as "some_table" without converting to upper case.</p>
<p>Changed in version 1.2: The <a href="#sqlalchemy.sql.expression.quoted_name">quoted_name</a> construct is now importable from sqlalchemy.sql, in addition to the previous location of sqlalchemy.sql.elements.</p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.quoted_name.quote">quote</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.quoted_name">sqlalchemy.sql.expression.quoted_name</a> (sqlalchemy.util.langhelpers.MemoizedSlots, builtins.str)</p>
<dl>
<dt id="sqlalchemy.sql.expression.quoted_name.quote">
attribute <a href="#sqlalchemy.sql.expression.quoted_name">sqlalchemy.sql.expression.quoted_name.</a>quote<a href="#sqlalchemy.sql.expression.quoted_name.quote">Â¶</a></dt>
<dd><p>whether the string should be unconditionally quoted</p>
</dd></dl>
</dd></dl>
<h2>Column Element Modifier Constructors<a href="#column-element-modifier-constructors">Â¶</a></h2>
<p>Functions listed here are more commonly available as methods from any <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> construct, for example, the <a href="#sqlalchemy.sql.expression.label">label()</a> function is usually invoked via the <a href="#sqlalchemy.sql.expression.ColumnElement.label">ColumnElement.label()</a> method.</p>
<table>
<tr><td><p><a href="#sqlalchemy.sql.expression.all_">all_</a>(expr)</p></td>
<td><p>Produce an ALL expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.any_">any_</a>(expr)</p></td>
<td><p>Produce an ANY expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.asc">asc</a>(column)</p></td>
<td><p>Produce an ascending ORDER BY clause element.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.between">between</a>(expr, lower_bound, upper_bound[, symmetric])</p></td>
<td><p>Produce a BETWEEN predicate clause.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.collate">collate</a>(expression, collation)</p></td>
<td><p>Return the clause expression COLLATE collation.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.desc">desc</a>(column)</p></td>
<td><p>Produce a descending ORDER BY clause element.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.funcfilter">funcfilter</a>(func, *criterion)</p></td>
<td><p>Produce a <a href="#sqlalchemy.sql.expression.FunctionFilter">FunctionFilter</a> object against a function.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.label">label</a>(name, element[, type_])</p></td>
<td><p>Return a <a href="#sqlalchemy.sql.expression.Label">Label</a> object for the given <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.nulls_first">nulls_first</a>(column)</p></td>
<td><p>Produce the NULLS FIRST modifier for an ORDER BY expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.nulls_last">nulls_last</a>(column)</p></td>
<td><p>Produce the NULLS LAST modifier for an ORDER BY expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.nullsfirst">nullsfirst</a></p></td>
<td><p>Synonym for the <a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> function.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.nullslast">nullslast</a></p></td>
<td><p>Legacy synonym for the <a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a> function.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.over">over</a>(element[, partition_by, order_by, range_, ...])</p></td>
<td><p>Produce an <a href="#sqlalchemy.sql.expression.Over">Over</a> object against a function.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.within_group">within_group</a>(element, *order_by)</p></td>
<td><p>Produce a <a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a> object against a function.</p></td>
</tr>
</table>
<dl>
<dt id="sqlalchemy.sql.expression.all_">
function sqlalchemy.sql.expression.all_(expr: _ColumnExpressionArgument[_T]) â CollectionAggregate[bool]<a href="#sqlalchemy.sql.expression.all_">Â¶</a></dt>
<dd><p>Produce an ALL expression.</p>
<p>For dialects such as that of PostgreSQL, this operator applies to usage of the <a href="type_basics.html#sqlalchemy.types.ARRAY">ARRAY</a> datatype, for that of MySQL, it may apply to a subquery. e.g.:</p>
<pre># renders on PostgreSQL:
# '5 = ALL (somearray)'
expr = 5 == all_(mytable.c.somearray)
# renders on MySQL:
# '5 = ALL (SELECT value FROM table)'
expr = 5 == all_(select(table.c.value))</pre>
<p>Comparison to NULL may work using None:</p>
<pre>None == all_(mytable.c.somearray)</pre>
<p>The any_() / all_() operators also feature a special âoperand flippingâ
behavior such that if any_() / all_() are used on the left side of a comparison using a standalone operator such as ==, !=, etc.
(not including operator methods such as <a href="#sqlalchemy.sql.expression.ColumnOperators.is_">ColumnOperators.is_()</a>) the rendered expression is flipped:</p>
<pre># would render '5 = ALL (column)`
all_(mytable.c.column) == 5</pre>
<p>Or with None, which note will not perform the usual step of rendering âISâ as is normally the case for NULL:</p>
<pre># would render 'NULL = ALL(somearray)'
all_(mytable.c.somearray) == None</pre>
<p>Changed in version 1.4.26: repaired the use of any_() / all_()
comparing to NULL on the right side to be flipped to the left.</p>
<p>The column-level <a href="#sqlalchemy.sql.expression.ColumnElement.all_">ColumnElement.all_()</a> method (not to be confused with <a href="type_basics.html#sqlalchemy.types.ARRAY">ARRAY</a> level <a href="type_basics.html#sqlalchemy.types.ARRAY.Comparator.all">Comparator.all()</a>) is shorthand for all_(col):</p>
<pre>5 == mytable.c.somearray.all_()</pre>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.all_">ColumnOperators.all_()</a></p>
<p><a href="#sqlalchemy.sql.expression.any_">any_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.any_">
function sqlalchemy.sql.expression.any_(expr: _ColumnExpressionArgument[_T]) â CollectionAggregate[bool]<a href="#sqlalchemy.sql.expression.any_">Â¶</a></dt>
<dd><p>Produce an ANY expression.</p>
<p>For dialects such as that of PostgreSQL, this operator applies to usage of the <a href="type_basics.html#sqlalchemy.types.ARRAY">ARRAY</a> datatype, for that of MySQL, it may apply to a subquery. e.g.:</p>
<pre># renders on PostgreSQL:
# '5 = ANY (somearray)'
expr = 5 == any_(mytable.c.somearray)
# renders on MySQL:
# '5 = ANY (SELECT value FROM table)'
expr = 5 == any_(select(table.c.value))</pre>
<p>Comparison to NULL may work using None or <a href="#sqlalchemy.sql.expression.null">null()</a>:</p>
<pre>None == any_(mytable.c.somearray)</pre>
<p>The any_() / all_() operators also feature a special âoperand flippingâ
behavior such that if any_() / all_() are used on the left side of a comparison using a standalone operator such as ==, !=, etc.
(not including operator methods such as <a href="#sqlalchemy.sql.expression.ColumnOperators.is_">ColumnOperators.is_()</a>) the rendered expression is flipped:</p>
<pre># would render '5 = ANY (column)`
any_(mytable.c.column) == 5</pre>
<p>Or with None, which note will not perform the usual step of rendering âISâ as is normally the case for NULL:</p>
<pre># would render 'NULL = ANY(somearray)'
any_(mytable.c.somearray) == None</pre>
<p>Changed in version 1.4.26: repaired the use of any_() / all_()
comparing to NULL on the right side to be flipped to the left.</p>
<p>The column-level <a href="#sqlalchemy.sql.expression.ColumnElement.any_">ColumnElement.any_()</a> method (not to be confused with <a href="type_basics.html#sqlalchemy.types.ARRAY">ARRAY</a> level <a href="type_basics.html#sqlalchemy.types.ARRAY.Comparator.any">Comparator.any()</a>) is shorthand for any_(col):</p>
<pre>5 = mytable.c.somearray.any_()</pre>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.any_">ColumnOperators.any_()</a></p>
<p><a href="#sqlalchemy.sql.expression.all_">all_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.asc">
function sqlalchemy.sql.expression.asc(column: _ColumnExpressionOrStrLabelArgument[_T]) â <a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a>[_T]<a href="#sqlalchemy.sql.expression.asc">Â¶</a></dt>
<dd><p>Produce an ascending ORDER BY clause element.</p>
<p>e.g.:</p>
<pre>from sqlalchemy import asc
stmt = select(users_table).order_by(asc(users_table.c.name))</pre>
<p>will produce SQL as:</p>
<pre>SELECT id, name FROM user ORDER BY name ASC</pre>
<p>The <a href="#sqlalchemy.sql.expression.asc">asc()</a> function is a standalone version of the <a href="#sqlalchemy.sql.expression.ColumnElement.asc">ColumnElement.asc()</a>
method available on all SQL expressions, e.g.:</p>
<pre>stmt = select(users_table).order_by(users_table.c.name.asc())</pre>
<dl>
<dt>Parameters:</dt>
<dd><p>column<a href="#sqlalchemy.sql.expression.asc.params.column">Â¶</a> â A <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> (e.g.
scalar SQL expression)
with which to apply the <a href="#sqlalchemy.sql.expression.asc">asc()</a> operation.</p>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.desc">desc()</a></p>
<p><a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a></p>
<p><a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a></p>
<p><a href="selectable.html#sqlalchemy.sql.expression.Select.order_by">Select.order_by()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.between">
function sqlalchemy.sql.expression.between(expr: _ColumnExpressionOrLiteralArgument[_T], lower_bound: Any, upper_bound: Any, symmetric: bool = False) â <a href="#sqlalchemy.sql.expression.BinaryExpression">BinaryExpression</a>[bool]<a href="#sqlalchemy.sql.expression.between">Â¶</a></dt>
<dd><p>Produce a BETWEEN predicate clause.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import between
stmt = select(users_table).where(between(users_table.c.id, 5, 7))</pre>
<p>Would produce SQL resembling:</p>
<pre>SELECT id, name FROM user WHERE id BETWEEN :id_1 AND :id_2</pre>
<p>The <a href="#sqlalchemy.sql.expression.between">between()</a> function is a standalone version of the <a href="#sqlalchemy.sql.expression.ColumnElement.between">ColumnElement.between()</a> method available on all SQL expressions, as in:</p>
<pre>stmt = select(users_table).where(users_table.c.id.between(5, 7))</pre>
<p>All arguments passed to <a href="#sqlalchemy.sql.expression.between">between()</a>, including the left side column expression, are coerced from Python scalar values if a the value is not a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> subclass.
For example, three fixed values can be compared as in:</p>
<pre>print(between(5, 3, 7))</pre>
<p>Which would produce:</p>
<pre>:param_1 BETWEEN :param_2 AND :param_3</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>expr<a href="#sqlalchemy.sql.expression.between.params.expr">Â¶</a> â a column expression, typically a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
instance or alternatively a Python scalar expression to be coerced into a column expression, serving as the left side of the BETWEEN expression.</p></li>
<li><p>lower_bound<a href="#sqlalchemy.sql.expression.between.params.lower_bound">Â¶</a> â a column or Python scalar expression serving as the lower bound of the right side of the BETWEEN expression.</p></li>
<li><p>upper_bound<a href="#sqlalchemy.sql.expression.between.params.upper_bound">Â¶</a> â a column or Python scalar expression serving as the upper bound of the right side of the BETWEEN expression.</p></li>
<li><p>symmetric<a href="#sqlalchemy.sql.expression.between.params.symmetric">Â¶</a> â if True, will render â BETWEEN SYMMETRIC â. Note that not all databases support this syntax.</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnElement.between">ColumnElement.between()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.collate">
function sqlalchemy.sql.expression.collate(expression: _ColumnExpressionArgument[str], collation: str) â <a href="#sqlalchemy.sql.expression.BinaryExpression">BinaryExpression</a>[str]<a href="#sqlalchemy.sql.expression.collate">Â¶</a></dt>
<dd><p>Return the clause expression COLLATE collation.</p>
<p>e.g.:</p>
<pre>collate(mycolumn, 'utf8_bin')</pre>
<p>produces:</p>
<pre>mycolumn COLLATE utf8_bin</pre>
<p>The collation expression is also quoted if it is a case sensitive identifier, e.g. contains uppercase characters.</p>
<p>Changed in version 1.2: quoting is automatically applied to COLLATE expressions if they are case sensitive.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.desc">
function sqlalchemy.sql.expression.desc(column: _ColumnExpressionOrStrLabelArgument[_T]) â <a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a>[_T]<a href="#sqlalchemy.sql.expression.desc">Â¶</a></dt>
<dd><p>Produce a descending ORDER BY clause element.</p>
<p>e.g.:</p>
<pre>from sqlalchemy import desc
stmt = select(users_table).order_by(desc(users_table.c.name))</pre>
<p>will produce SQL as:</p>
<pre>SELECT id, name FROM user ORDER BY name DESC</pre>
<p>The <a href="#sqlalchemy.sql.expression.desc">desc()</a> function is a standalone version of the <a href="#sqlalchemy.sql.expression.ColumnElement.desc">ColumnElement.desc()</a>
method available on all SQL expressions, e.g.:</p>
<pre>stmt = select(users_table).order_by(users_table.c.name.desc())</pre>
<dl>
<dt>Parameters:</dt>
<dd><p>column<a href="#sqlalchemy.sql.expression.desc.params.column">Â¶</a> â A <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> (e.g.
scalar SQL expression)
with which to apply the <a href="#sqlalchemy.sql.expression.desc">desc()</a> operation.</p>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.asc">asc()</a></p>
<p><a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a></p>
<p><a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a></p>
<p><a href="selectable.html#sqlalchemy.sql.expression.Select.order_by">Select.order_by()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.funcfilter">
function sqlalchemy.sql.expression.funcfilter(func: <a href="functions.html#sqlalchemy.sql.functions.FunctionElement">FunctionElement</a>[_T], *criterion: _ColumnExpressionArgument[bool]) â <a href="#sqlalchemy.sql.expression.FunctionFilter">FunctionFilter</a>[_T]<a href="#sqlalchemy.sql.expression.funcfilter">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.FunctionFilter">FunctionFilter</a> object against a function.</p>
<p>Used against aggregate and window functions, for database backends that support the âFILTERâ clause.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import funcfilter
funcfilter(func.count(1), MyClass.name == 'some name')</pre>
<p>Would produce âCOUNT(1) FILTER (WHERE myclass.name = âsome nameâ)â.</p>
<p>This function is also available from the <a href="#sqlalchemy.sql.expression.func">func</a>
construct itself via the <a href="functions.html#sqlalchemy.sql.functions.FunctionElement.filter">FunctionElement.filter()</a> method.</p>
<p>See also</p>
<p><a href="../tutorial/data_select.html#tutorial-functions-within-group">Special Modifiers WITHIN GROUP, FILTER</a> - in the <a href="../tutorial/index.html#unified-tutorial">SQLAlchemy Unified Tutorial</a></p>
<p><a href="functions.html#sqlalchemy.sql.functions.FunctionElement.filter">FunctionElement.filter()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.label">
function sqlalchemy.sql.expression.label(name: str, element: _ColumnExpressionArgument[_T], type_: _TypeEngineArgument[_T] | None = None) â <a href="#sqlalchemy.sql.expression.Label">Label</a>[_T]<a href="#sqlalchemy.sql.expression.label">Â¶</a></dt>
<dd><p>Return a <a href="#sqlalchemy.sql.expression.Label">Label</a> object for the given <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>.</p>
<p>A label changes the name of an element in the columns clause of a SELECT statement, typically via the AS SQL keyword.</p>
<p>This functionality is more conveniently available via the <a href="#sqlalchemy.sql.expression.ColumnElement.label">ColumnElement.label()</a> method on <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>name<a href="#sqlalchemy.sql.expression.label.params.name">Â¶</a> â label name</p></li>
<li><p>obj<a href="#sqlalchemy.sql.expression.label.params.obj">Â¶</a> â a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.nulls_first">
function sqlalchemy.sql.expression.nulls_first(column: _ColumnExpressionArgument[_T]) â <a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a>[_T]<a href="#sqlalchemy.sql.expression.nulls_first">Â¶</a></dt>
<dd><p>Produce the NULLS FIRST modifier for an ORDER BY expression.</p>
<p><a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> is intended to modify the expression produced by <a href="#sqlalchemy.sql.expression.asc">asc()</a> or <a href="#sqlalchemy.sql.expression.desc">desc()</a>, and indicates how NULL values should be handled when they are encountered during ordering:</p>
<pre>from sqlalchemy import desc, nulls_first
stmt = select(users_table).order_by(
nulls_first(desc(users_table.c.name)))</pre>
<p>The SQL expression from the above would resemble:</p>
<pre>SELECT id, name FROM user ORDER BY name DESC NULLS FIRST</pre>
<p>Like <a href="#sqlalchemy.sql.expression.asc">asc()</a> and <a href="#sqlalchemy.sql.expression.desc">desc()</a>, <a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> is typically invoked from the column expression itself using <a href="#sqlalchemy.sql.expression.ColumnElement.nulls_first">ColumnElement.nulls_first()</a>, rather than as its standalone function version, as in:</p>
<pre>stmt = select(users_table).order_by(
users_table.c.name.desc().nulls_first())</pre>
<p>Changed in version 1.4: <a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> is renamed from <a href="#sqlalchemy.sql.expression.nullsfirst">nullsfirst()</a> in previous releases.
The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.asc">asc()</a></p>
<p><a href="#sqlalchemy.sql.expression.desc">desc()</a></p>
<p><a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a></p>
<p><a href="selectable.html#sqlalchemy.sql.expression.Select.order_by">Select.order_by()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.nullsfirst">
function sqlalchemy.sql.expression.nullsfirst()<a href="#sqlalchemy.sql.expression.nullsfirst">Â¶</a></dt>
<dd><p>Synonym for the <a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> function.</p>
<p>Changed in version 2.0.5: restored missing legacy symbol <a href="#sqlalchemy.sql.expression.nullsfirst">nullsfirst()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.nulls_last">
function sqlalchemy.sql.expression.nulls_last(column: _ColumnExpressionArgument[_T]) â <a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a>[_T]<a href="#sqlalchemy.sql.expression.nulls_last">Â¶</a></dt>
<dd><p>Produce the NULLS LAST modifier for an ORDER BY expression.</p>
<p><a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a> is intended to modify the expression produced by <a href="#sqlalchemy.sql.expression.asc">asc()</a> or <a href="#sqlalchemy.sql.expression.desc">desc()</a>, and indicates how NULL values should be handled when they are encountered during ordering:</p>
<pre>from sqlalchemy import desc, nulls_last
stmt = select(users_table).order_by(
nulls_last(desc(users_table.c.name)))</pre>
<p>The SQL expression from the above would resemble:</p>
<pre>SELECT id, name FROM user ORDER BY name DESC NULLS LAST</pre>
<p>Like <a href="#sqlalchemy.sql.expression.asc">asc()</a> and <a href="#sqlalchemy.sql.expression.desc">desc()</a>, <a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a> is typically invoked from the column expression itself using <a href="#sqlalchemy.sql.expression.ColumnElement.nulls_last">ColumnElement.nulls_last()</a>, rather than as its standalone function version, as in:</p>
<pre>stmt = select(users_table).order_by(
users_table.c.name.desc().nulls_last())</pre>
<p>Changed in version 1.4: <a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a> is renamed from <a href="#sqlalchemy.sql.expression.nullslast">nullslast()</a> in previous releases.
The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.asc">asc()</a></p>
<p><a href="#sqlalchemy.sql.expression.desc">desc()</a></p>
<p><a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a></p>
<p><a href="selectable.html#sqlalchemy.sql.expression.Select.order_by">Select.order_by()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.nullslast">
function sqlalchemy.sql.expression.nullslast()<a href="#sqlalchemy.sql.expression.nullslast">Â¶</a></dt>
<dd><p>Legacy synonym for the <a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a> function.</p>
<p>Changed in version 2.0.5: restored missing legacy symbol <a href="#sqlalchemy.sql.expression.nullslast">nullslast()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.over">
function sqlalchemy.sql.expression.over(element: <a href="functions.html#sqlalchemy.sql.functions.FunctionElement">FunctionElement</a>[_T], partition_by: _ByArgument | None = None, order_by: _ByArgument | None = None, range_: typing_Tuple[int | None, int | None] | None = None, rows: typing_Tuple[int | None, int | None] | None = None) â <a href="#sqlalchemy.sql.expression.Over">Over</a>[_T]<a href="#sqlalchemy.sql.expression.over">Â¶</a></dt>
<dd><p>Produce an <a href="#sqlalchemy.sql.expression.Over">Over</a> object against a function.</p>
<p>Used against aggregate or so-called âwindowâ functions, for database backends that support window functions.</p>
<p><a href="#sqlalchemy.sql.expression.over">over()</a> is usually called using the <a href="functions.html#sqlalchemy.sql.functions.FunctionElement.over">FunctionElement.over()</a> method, e.g.:</p>
<pre>func.row_number().over(order_by=mytable.c.some_column)</pre>
<p>Would produce:</p>
<pre>ROW_NUMBER() OVER(ORDER BY some_column)</pre>
<p>Ranges are also possible using the <a href="#sqlalchemy.sql.expression.over.params.range_">over.range_</a>
and <a href="#sqlalchemy.sql.expression.over.params.rows">over.rows</a> parameters. These mutually-exclusive parameters each accept a 2-tuple, which contains a combination of integers and None:</p>
<pre>func.row_number().over(
order_by=my_table.c.some_column, range_=(None, 0))</pre>
<p>The above would produce:</p>
<pre>ROW_NUMBER() OVER(ORDER BY some_column
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)</pre>
<p>A value of None indicates âunboundedâ, a value of zero indicates âcurrent rowâ, and negative / positive integers indicate âprecedingâ and âfollowingâ:</p>
<ul>
<li><p>RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING:</p>
<pre>func.row_number().over(order_by='x', range_=(-5, 10))</pre>
</li>
<li><p>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW:</p>
<pre>func.row_number().over(order_by='x', rows=(None, 0))</pre>
</li>
<li><p>RANGE BETWEEN 2 PRECEDING AND UNBOUNDED FOLLOWING:</p>
<pre>func.row_number().over(order_by='x', range_=(-2, None))</pre>
</li>
<li><p>RANGE BETWEEN 1 FOLLOWING AND 3 FOLLOWING:</p>
<pre>func.row_number().over(order_by='x', range_=(1, 3))</pre>
</li>
</ul>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>element<a href="#sqlalchemy.sql.expression.over.params.element">Â¶</a> â a <a href="functions.html#sqlalchemy.sql.functions.FunctionElement">FunctionElement</a>, <a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a>, or other compatible construct.</p></li>
<li><p>partition_by<a href="#sqlalchemy.sql.expression.over.params.partition_by">Â¶</a> â a column element or string, or a list of such, that will be used as the PARTITION BY clause of the OVER construct.</p></li>
<li><p>order_by<a href="#sqlalchemy.sql.expression.over.params.order_by">Â¶</a> â a column element or string, or a list of such, that will be used as the ORDER BY clause of the OVER construct.</p></li>
<li><p>range_<a href="#sqlalchemy.sql.expression.over.params.range_">Â¶</a> â optional range clause for the window. This is a tuple value which can contain integer values or None, and will render a RANGE BETWEEN PRECEDING / FOLLOWING clause.</p></li>
<li><p>rows<a href="#sqlalchemy.sql.expression.over.params.rows">Â¶</a> â optional rows clause for the window. This is a tuple value which can contain integer values or None, and will render a ROWS BETWEEN PRECEDING / FOLLOWING clause.</p></li>
</ul>
</dd>
</dl>
<p>This function is also available from the <a href="#sqlalchemy.sql.expression.func">func</a>
construct itself via the <a href="functions.html#sqlalchemy.sql.functions.FunctionElement.over">FunctionElement.over()</a> method.</p>
<p>See also</p>
<p><a href="../tutorial/data_select.html#tutorial-window-functions">Using Window Functions</a> - in the <a href="../tutorial/index.html#unified-tutorial">SQLAlchemy Unified Tutorial</a></p>
<p><a href="#sqlalchemy.sql.expression.func">func</a></p>
<p><a href="#sqlalchemy.sql.expression.within_group">within_group()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.within_group">
function sqlalchemy.sql.expression.within_group(element: <a href="functions.html#sqlalchemy.sql.functions.FunctionElement">FunctionElement</a>[_T], *order_by: _ColumnExpressionArgument[Any]) â <a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a>[_T]<a href="#sqlalchemy.sql.expression.within_group">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a> object against a function.</p>
<p>Used against so-called âordered set aggregateâ and âhypothetical set aggregateâ functions, including <a href="functions.html#sqlalchemy.sql.functions.percentile_cont">percentile_cont</a>, <a href="functions.html#sqlalchemy.sql.functions.rank">rank</a>, <a href="functions.html#sqlalchemy.sql.functions.dense_rank">dense_rank</a>, etc.</p>
<p><a href="#sqlalchemy.sql.expression.within_group">within_group()</a> is usually called using the <a href="functions.html#sqlalchemy.sql.functions.FunctionElement.within_group">FunctionElement.within_group()</a> method, e.g.:</p>
<pre>from sqlalchemy import within_group
stmt = select(
department.c.id,
func.percentile_cont(0.5).within_group(
department.c.salary.desc()
)
)</pre>
<p>The above statement would produce SQL similar to SELECT department.id, percentile_cont(0.5)
WITHIN GROUP (ORDER BY department.salary DESC).</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>element<a href="#sqlalchemy.sql.expression.within_group.params.element">Â¶</a> â a <a href="functions.html#sqlalchemy.sql.functions.FunctionElement">FunctionElement</a> construct, typically generated by <a href="#sqlalchemy.sql.expression.func">func</a>.</p></li>
<li><p>*order_by<a href="#sqlalchemy.sql.expression.within_group.params.*order_by">Â¶</a> â one or more column elements that will be used as the ORDER BY clause of the WITHIN GROUP construct.</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="../tutorial/data_select.html#tutorial-functions-within-group">Special Modifiers WITHIN GROUP, FILTER</a> - in the <a href="../tutorial/index.html#unified-tutorial">SQLAlchemy Unified Tutorial</a></p>
<p><a href="#sqlalchemy.sql.expression.func">func</a></p>
<p><a href="#sqlalchemy.sql.expression.over">over()</a></p>
</dd></dl>
<h2>Column Element Class Documentation<a href="#column-element-class-documentation">Â¶</a></h2>
<p>The classes here are generated using the constructors listed at <a href="#sqlelement-foundational-constructors">Column Element Foundational Constructors</a> and <a href="#sqlelement-modifier-constructors">Column Element Modifier Constructors</a>.</p>
<table>
<tr><td><p><a href="#sqlalchemy.sql.expression.BinaryExpression">BinaryExpression</a></p></td>
<td><p>Represent an expression that is LEFT &lt;operator&gt; RIGHT.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a></p></td>
<td><p>Represent a âbound expressionâ.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.Case">Case</a></p></td>
<td><p>Represent a CASE expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.Cast">Cast</a></p></td>
<td><p>Represent a CAST expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.ClauseList">ClauseList</a></p></td>
<td><p>Describe a list of clauses, separated by an operator.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a></p></td>
<td><p>Represents a column expression from any textual string.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a></p></td>
<td><p>Collection of <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> instances, typically for <a href="selectable.html#sqlalchemy.sql.expression.FromClause">FromClause</a> objects.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a></p></td>
<td><p>Represent a column-oriented SQL expression suitable for usage in the âcolumnsâ clause, WHERE clause etc. of a statement.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.ColumnExpressionArgument">ColumnExpressionArgument</a></p></td>
<td><p>General purpose âcolumn expressionâ argument.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p></td>
<td><p>Defines boolean, comparison, and other operators for <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> expressions.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.Extract">Extract</a></p></td>
<td><p>Represent a SQL EXTRACT clause, extract(field FROM expr).</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.False_">False_</a></p></td>
<td><p>Represent the false keyword, or equivalent, in a SQL statement.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.FunctionFilter">FunctionFilter</a></p></td>
<td><p>Represent a function FILTER clause.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.Label">Label</a></p></td>
<td><p>Represents a column label (AS).</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.Null">Null</a></p></td>
<td><p>Represent the NULL keyword in a SQL statement.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.Operators">Operators</a></p></td>
<td><p>Base of comparison and logical operators.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.Over">Over</a></p></td>
<td><p>Represent an OVER clause.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.SQLColumnExpression">SQLColumnExpression</a></p></td>
<td><p>A type that may be used to indicate any SQL column element or object that acts in place of one.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.TextClause">TextClause</a></p></td>
<td><p>Represent a literal SQL text fragment.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.True_">True_</a></p></td>
<td><p>Represent the true keyword, or equivalent, in a SQL statement.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.TryCast">TryCast</a></p></td>
<td><p>Represent a TRY_CAST expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.Tuple">Tuple</a></p></td>
<td><p>Represent a SQL tuple.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.TypeCoerce">TypeCoerce</a></p></td>
<td><p>Represent a Python-side type-coercion wrapper.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a></p></td>
<td><p>Define a âunaryâ expression.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a></p></td>
<td><p>Represent a WITHIN GROUP (ORDER BY) clause.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.sql.elements.WrapsColumnExpression">WrapsColumnExpression</a></p></td>
<td><p>Mixin that defines a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
as a wrapper with special labeling behavior for an expression that already has a name.</p></td>
</tr>
</table>
<dl>
<dt id="sqlalchemy.sql.expression.BinaryExpression">
class sqlalchemy.sql.expression.BinaryExpression<a href="#sqlalchemy.sql.expression.BinaryExpression">Â¶</a></dt>
<dd><p>Represent an expression that is LEFT &lt;operator&gt; RIGHT.</p>
<p>A <a href="#sqlalchemy.sql.expression.BinaryExpression">BinaryExpression</a> is generated automatically whenever two column expressions are used in a Python binary expression:</p>
<pre>&gt;&gt;&gt; from sqlalchemy.sql import column
&gt;&gt;&gt; column('a') + column('b')
&lt;sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0&gt;
&gt;&gt;&gt; print(column('a') + column('b'))
a + b
</pre>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.BinaryExpression">sqlalchemy.sql.expression.BinaryExpression</a> (sqlalchemy.sql.expression.OperatorExpression)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.BindParameter">
class sqlalchemy.sql.expression.BindParameter<a href="#sqlalchemy.sql.expression.BindParameter">Â¶</a></dt>
<dd><p>Represent a âbound expressionâ.</p>
<p><a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> is invoked explicitly using the <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> function, as in:</p>
<pre>from sqlalchemy import bindparam
stmt = select(users_table).where(
users_table.c.name == bindparam("username")
)</pre>
<p>Detailed discussion of how <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> is used is at <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a>.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a></p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.BindParameter.effective_value">effective_value</a>, <a href="#sqlalchemy.sql.expression.BindParameter.inherit_cache">inherit_cache</a>, <a href="#sqlalchemy.sql.expression.BindParameter.render_literal_execute">render_literal_execute()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.BindParameter">sqlalchemy.sql.expression.BindParameter</a> (sqlalchemy.sql.roles.InElementRole, sqlalchemy.sql.expression.KeyedColumnElement)</p>
<dl>
<dt id="sqlalchemy.sql.expression.BindParameter.effective_value">
attribute <a href="#sqlalchemy.sql.expression.BindParameter">sqlalchemy.sql.expression.BindParameter.</a>effective_value<a href="#sqlalchemy.sql.expression.BindParameter.effective_value">Â¶</a></dt>
<dd><p>Return the value of this bound parameter, taking into account if the callable parameter was set.</p>
<p>The callable value will be evaluated and returned if present, else value.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.BindParameter.inherit_cache">
attribute <a href="#sqlalchemy.sql.expression.BindParameter">sqlalchemy.sql.expression.BindParameter.</a>inherit_cache: bool | None = True<a href="#sqlalchemy.sql.expression.BindParameter.inherit_cache">Â¶</a></dt>
<dd><p>Indicate if this <a href="foundation.html#sqlalchemy.sql.traversals.HasCacheKey">HasCacheKey</a> instance should make use of the cache key generation scheme used by its immediate superclass.</p>
<p>The attribute defaults to None, which indicates that a construct has not yet taken into account whether or not its appropriate for it to participate in caching; this is functionally equivalent to setting the value to False, except that a warning is also emitted.</p>
<p>This flag can be set to True on a particular class, if the SQL that corresponds to the object does not change based on attributes which are local to this class, and not its superclass.</p>
<p>See also</p>
<p><a href="compiler.html#compilerext-caching">Enabling Caching Support for Custom Constructs</a> - General guideslines for setting the <a href="foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache">HasCacheKey.inherit_cache</a> attribute for third-party or user defined SQL constructs.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.BindParameter.render_literal_execute">
method <a href="#sqlalchemy.sql.expression.BindParameter">sqlalchemy.sql.expression.BindParameter.</a>render_literal_execute() â <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a>[_T]<a href="#sqlalchemy.sql.expression.BindParameter.render_literal_execute">Â¶</a></dt>
<dd><p>Produce a copy of this bound parameter that will enable the <a href="#sqlalchemy.sql.expression.BindParameter.params.literal_execute">BindParameter.literal_execute</a> flag.</p>
<p>The <a href="#sqlalchemy.sql.expression.BindParameter.params.literal_execute">BindParameter.literal_execute</a> flag will have the effect of the parameter rendered in the compiled SQL string using [POSTCOMPILE] form, which is a special form that is converted to be a rendering of the literal value of the parameter at SQL execution time. The rationale is to support caching of SQL statement strings that can embed per-statement literal values, such as LIMIT and OFFSET parameters, in the final SQL string that is passed to the DBAPI. Dialects in particular may want to use this method within custom compilation schemes.</p>
<p>New in version 1.4.5.</p>
<p>See also</p>
<p><a href="connections.html#engine-thirdparty-caching">Caching for Third Party Dialects</a></p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Case">
class sqlalchemy.sql.expression.Case<a href="#sqlalchemy.sql.expression.Case">Â¶</a></dt>
<dd><p>Represent a CASE expression.</p>
<p><a href="#sqlalchemy.sql.expression.Case">Case</a> is produced using the <a href="#sqlalchemy.sql.expression.case">case()</a> factory function, as in:</p>
<pre>from sqlalchemy import case
stmt = select(users_table). where(
case(
(users_table.c.name == 'wendy', 'W'),
(users_table.c.name == 'jack', 'J'),
else_='E'
)
)</pre>
<p>Details on <a href="#sqlalchemy.sql.expression.Case">Case</a> usage is at <a href="#sqlalchemy.sql.expression.case">case()</a>.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.case">case()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.Case">sqlalchemy.sql.expression.Case</a> (<a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Cast">
class sqlalchemy.sql.expression.Cast<a href="#sqlalchemy.sql.expression.Cast">Â¶</a></dt>
<dd><p>Represent a CAST expression.</p>
<p><a href="#sqlalchemy.sql.expression.Cast">Cast</a> is produced using the <a href="#sqlalchemy.sql.expression.cast">cast()</a> factory function, as in:</p>
<pre>from sqlalchemy import cast, Numeric
stmt = select(cast(product_table.c.unit_price, Numeric(10, 4)))</pre>
<p>Details on <a href="#sqlalchemy.sql.expression.Cast">Cast</a> usage is at <a href="#sqlalchemy.sql.expression.cast">cast()</a>.</p>
<p>See also</p>
<p><a href="../tutorial/data_select.html#tutorial-casts">Data Casts and Type Coercion</a></p>
<p><a href="#sqlalchemy.sql.expression.cast">cast()</a></p>
<p><a href="#sqlalchemy.sql.expression.try_cast">try_cast()</a></p>
<p><a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a> - an alternative to CAST that coerces the type on the Python side only, which is often sufficient to generate the correct SQL and data coercion.</p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.Cast">sqlalchemy.sql.expression.Cast</a> (sqlalchemy.sql.expression.WrapsColumnExpression)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ClauseList">
class sqlalchemy.sql.expression.ClauseList<a href="#sqlalchemy.sql.expression.ClauseList">Â¶</a></dt>
<dd><p>Describe a list of clauses, separated by an operator.</p>
<p>By default, is comma-separated, such as a column listing.</p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.ClauseList.self_group">self_group()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.ClauseList">sqlalchemy.sql.expression.ClauseList</a> (sqlalchemy.sql.roles.InElementRole, sqlalchemy.sql.roles.OrderByRole, sqlalchemy.sql.roles.ColumnsClauseRole, sqlalchemy.sql.roles.DMLColumnRole, sqlalchemy.sql.expression.DQLDMLClauseElement)</p>
<dl>
<dt id="sqlalchemy.sql.expression.ClauseList.self_group">
method <a href="#sqlalchemy.sql.expression.ClauseList">sqlalchemy.sql.expression.ClauseList.</a>self_group(against: OperatorType | None = None) â Self | Grouping[Any]<a href="#sqlalchemy.sql.expression.ClauseList.self_group">Â¶</a></dt>
<dd><p>Apply a âgroupingâ to this <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>.</p>
<p>This method is overridden by subclasses to return a âgroupingâ
construct, i.e. parenthesis. In particular itâs used by âbinaryâ
expressions to provide a grouping around themselves when placed into a larger expression, as well as by <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
constructs when placed into the FROM clause of another <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>. (Note that subqueries should be normally created using the <a href="selectable.html#sqlalchemy.sql.expression.Select.alias">Select.alias()</a> method, as many platforms require nested SELECT statements to be named).</p>
<p>As expressions are composed together, the application of <a href="#sqlalchemy.sql.expression.ClauseList.self_group">self_group()</a> is automatic - end-user code should never need to use this method directly. Note that SQLAlchemyâs clause constructs take operator precedence into account -
so parenthesis might not be needed, for example, in an expression like x OR (y AND z) - AND takes precedence over OR.</p>
<p>The base <a href="#sqlalchemy.sql.expression.ClauseList.self_group">self_group()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>
just returns self.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnClause">
class sqlalchemy.sql.expression.ColumnClause<a href="#sqlalchemy.sql.expression.ColumnClause">Â¶</a></dt>
<dd><p>Represents a column expression from any textual string.</p>
<p>The <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a>, a lightweight analogue to the <a href="metadata.html#sqlalchemy.schema.Column">Column</a> class, is typically invoked using the <a href="#sqlalchemy.sql.expression.column">column()</a> function, as in:</p>
<pre>from sqlalchemy import column
id, name = column("id"), column("name")
stmt = select(id, name).select_from("user")</pre>
<p>The above statement would produce SQL like:</p>
<pre>SELECT id, name FROM user</pre>
<p><a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> is the immediate superclass of the schema-specific <a href="metadata.html#sqlalchemy.schema.Column">Column</a> object. While the <a href="metadata.html#sqlalchemy.schema.Column">Column</a>
class has all the same capabilities as <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a>, the <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a>
class is usable by itself in those cases where behavioral requirements are limited to simple SQL expression generation. The object has none of the associations with schema-level metadata or with execution-time behavior that <a href="metadata.html#sqlalchemy.schema.Column">Column</a> does, so in that sense is a âlightweightâ
version of <a href="metadata.html#sqlalchemy.schema.Column">Column</a>.</p>
<p>Full details on <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> usage is at <a href="#sqlalchemy.sql.expression.column">column()</a>.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.column">column()</a></p>
<p><a href="metadata.html#sqlalchemy.schema.Column">Column</a></p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.ColumnClause.get_children">get_children()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.ColumnClause">sqlalchemy.sql.expression.ColumnClause</a> (sqlalchemy.sql.roles.DDLReferredColumnRole, sqlalchemy.sql.roles.LabeledColumnExprRole, sqlalchemy.sql.roles.StrAsPlainColumnRole, sqlalchemy.sql.expression.Immutable, sqlalchemy.sql.expression.NamedColumn)</p>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnClause.get_children">
method <a href="#sqlalchemy.sql.expression.ColumnClause">sqlalchemy.sql.expression.ColumnClause.</a>get_children(*, column_tables=False, **kw)<a href="#sqlalchemy.sql.expression.ColumnClause.get_children">Â¶</a></dt>
<dd><p>Return immediate child HasTraverseInternals elements of this HasTraverseInternals.</p>
<p>This is used for visit traversal.</p>
<p>**kw may contain flags that change the collection that is returned, for example to return a subset of items in order to cut down on larger traversals, or to return child items from a different context (such as schema-level collections instead of clause-level).</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection">
class sqlalchemy.sql.expression.ColumnCollection<a href="#sqlalchemy.sql.expression.ColumnCollection">Â¶</a></dt>
<dd><p>Collection of <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> instances, typically for <a href="selectable.html#sqlalchemy.sql.expression.FromClause">FromClause</a> objects.</p>
<p>The <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a> object is most commonly available as the <a href="metadata.html#sqlalchemy.schema.Table.c">Table.c</a> or <a href="metadata.html#sqlalchemy.schema.Table.columns">Table.columns</a> collection on the <a href="metadata.html#sqlalchemy.schema.Table">Table</a> object, introduced at <a href="metadata.html#metadata-tables-and-columns">Accessing Tables and Columns</a>.</p>
<p>The <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a> has both mapping- and sequence-
like behaviors. A <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a> usually stores <a href="metadata.html#sqlalchemy.schema.Column">Column</a> objects, which are then accessible both via mapping style access as well as attribute access style.</p>
<p>To access <a href="metadata.html#sqlalchemy.schema.Column">Column</a> objects using ordinary attribute-style access, specify the name like any other object attribute, such as below a column named employee_name is accessed:</p>
<pre>&gt;&gt;&gt; employee_table.c.employee_name</pre>
<p>To access columns that have names with special characters or spaces, index-style access is used, such as below which illustrates a column named employee ' payment is accessed:</p>
<pre>&gt;&gt;&gt; employee_table.c["employee ' payment"]</pre>
<p>As the <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a> object provides a Python dictionary interface, common dictionary method names like <a href="#sqlalchemy.sql.expression.ColumnCollection.keys">ColumnCollection.keys()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.values">ColumnCollection.values()</a>, and <a href="#sqlalchemy.sql.expression.ColumnCollection.items">ColumnCollection.items()</a> are available, which means that database columns that are keyed under these names also need to use indexed access:</p>
<pre>&gt;&gt;&gt; employee_table.c["values"]</pre>
<p>The name for which a <a href="metadata.html#sqlalchemy.schema.Column">Column</a> would be present is normally that of the <a href="metadata.html#sqlalchemy.schema.Column.params.key">Column.key</a> parameter. In some contexts, such as a <a href="selectable.html#sqlalchemy.sql.expression.Select">Select</a> object that uses a label style set using the <a href="selectable.html#sqlalchemy.sql.expression.Select.set_label_style">Select.set_label_style()</a> method, a column of a certain key may instead be represented under a particular label name such as tablename_columnname:</p>
<pre>&gt;&gt;&gt; from sqlalchemy import select, column, table
&gt;&gt;&gt; from sqlalchemy import LABEL_STYLE_TABLENAME_PLUS_COL
&gt;&gt;&gt; t = table("t", column("c"))
&gt;&gt;&gt; stmt = select(t).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
&gt;&gt;&gt; subq = stmt.subquery()
&gt;&gt;&gt; subq.c.t_c
&lt;sqlalchemy.sql.elements.ColumnClause at 0x7f59dcf04fa0; t_c&gt;</pre>
<p><a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a> also indexes the columns in order and allows them to be accessible by their integer position:</p>
<pre>&gt;&gt;&gt; cc[0]
Column('x', Integer(), table=None)
&gt;&gt;&gt; cc[1]
Column('y', Integer(), table=None)</pre>
<p>New in version 1.4: <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>
allows integer-based index access to the collection.</p>
<p>Iterating the collection yields the column expressions in order:</p>
<pre>&gt;&gt;&gt; list(cc)
[Column('x', Integer(), table=None),
Column('y', Integer(), table=None)]</pre>
<p>The base <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a> object can store duplicates, which can mean either two columns with the same key, in which case the column returned by key access is arbitrary:</p>
<pre>&gt;&gt;&gt; x1, x2 = Column('x', Integer), Column('x', Integer)
&gt;&gt;&gt; cc = ColumnCollection(columns=[(x1.name, x1), (x2.name, x2)])
&gt;&gt;&gt; list(cc)
[Column('x', Integer(), table=None),
Column('x', Integer(), table=None)]
&gt;&gt;&gt; cc['x'] is x1
False
&gt;&gt;&gt; cc['x'] is x2
True</pre>
<p>Or it can also mean the same column multiple times. These cases are supported as <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>
is used to represent the columns in a SELECT statement which may include duplicates.</p>
<p>A special subclass DedupeColumnCollection exists which instead maintains SQLAlchemyâs older behavior of not allowing duplicates; this collection is used for schema level objects like <a href="metadata.html#sqlalchemy.schema.Table">Table</a>
and <a href="constraints.html#sqlalchemy.schema.PrimaryKeyConstraint">PrimaryKeyConstraint</a> where this deduping is helpful. The DedupeColumnCollection class also has additional mutation methods as the schema constructs have more use cases that require removal and replacement of columns.</p>
<p>Changed in version 1.4: <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>
now stores duplicate column keys as well as the same column in multiple positions. The DedupeColumnCollection class is added to maintain the former behavior in those cases where deduplication as well as additional replace/remove operations are needed.</p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.ColumnCollection.add">add()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.as_readonly">as_readonly()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.clear">clear()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.compare">compare()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.contains_column">contains_column()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.corresponding_column">corresponding_column()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.get">get()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.items">items()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.keys">keys()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.update">update()</a>, <a href="#sqlalchemy.sql.expression.ColumnCollection.values">values()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection</a> (typing.Generic)</p>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.add">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>add(column: <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>[Any], key: _COLKEY | None = None) â None<a href="#sqlalchemy.sql.expression.ColumnCollection.add">Â¶</a></dt>
<dd><p>Add a column to this <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>.</p>
<p>Note</p>
<p>This method is not normally used by user-facing code, as the <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a> is usually part of an existing object such as a <a href="metadata.html#sqlalchemy.schema.Table">Table</a>. To add a <a href="metadata.html#sqlalchemy.schema.Column">Column</a> to an existing <a href="metadata.html#sqlalchemy.schema.Table">Table</a>
object, use the <a href="metadata.html#sqlalchemy.schema.Table.append_column">Table.append_column()</a> method.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.as_readonly">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>as_readonly() â ReadOnlyColumnCollection[_COLKEY, _COL_co]<a href="#sqlalchemy.sql.expression.ColumnCollection.as_readonly">Â¶</a></dt>
<dd><p>Return a âread onlyâ form of this <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.clear">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>clear() â NoReturn<a href="#sqlalchemy.sql.expression.ColumnCollection.clear">Â¶</a></dt>
<dd><p>Dictionary clear() is not implemented for <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.compare">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>compare(other: <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>[Any, Any]) â bool<a href="#sqlalchemy.sql.expression.ColumnCollection.compare">Â¶</a></dt>
<dd><p>Compare this <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a> to another based on the names of the keys</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.contains_column">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>contains_column(col: <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>[Any]) â bool<a href="#sqlalchemy.sql.expression.ColumnCollection.contains_column">Â¶</a></dt>
<dd><p>Checks if a column object exists in this collection</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.corresponding_column">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>corresponding_column(column: _COL, require_embedded: bool = False) â _COL | _COL_co | None<a href="#sqlalchemy.sql.expression.ColumnCollection.corresponding_column">Â¶</a></dt>
<dd><p>Given a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>, return the exported <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> object from this <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>
which corresponds to that original <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
via a common ancestor column.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>column<a href="#sqlalchemy.sql.expression.ColumnCollection.corresponding_column.params.column">Â¶</a> â the target <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
to be matched.</p></li>
<li><p>require_embedded<a href="#sqlalchemy.sql.expression.ColumnCollection.corresponding_column.params.require_embedded">Â¶</a> â only return corresponding columns for the given <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>, if the given <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
is actually present within a sub-element of this <a href="selectable.html#sqlalchemy.sql.expression.Selectable">Selectable</a>.
Normally the column will match if it merely shares a common ancestor with one of the exported columns of this <a href="selectable.html#sqlalchemy.sql.expression.Selectable">Selectable</a>.</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="selectable.html#sqlalchemy.sql.expression.Selectable.corresponding_column">Selectable.corresponding_column()</a>
- invokes this method against the collection returned by <a href="selectable.html#sqlalchemy.sql.expression.Selectable.exported_columns">Selectable.exported_columns</a>.</p>
<p>Changed in version 1.4: the implementation for corresponding_column was moved onto the <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a> itself.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.get">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>get(key: str, default: _COL | None = None) â _COL | _COL_co | None<a href="#sqlalchemy.sql.expression.ColumnCollection.get">Â¶</a></dt>
<dd><p>Get a <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> or <a href="metadata.html#sqlalchemy.schema.Column">Column</a> object based on a string key name from this <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.items">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>items() â List[Tuple[_COLKEY, _COL_co]]<a href="#sqlalchemy.sql.expression.ColumnCollection.items">Â¶</a></dt>
<dd><p>Return a sequence of (key, column) tuples for all columns in this collection each consisting of a string key name and a <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> or <a href="metadata.html#sqlalchemy.schema.Column">Column</a> object.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.keys">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>keys() â List[_COLKEY]<a href="#sqlalchemy.sql.expression.ColumnCollection.keys">Â¶</a></dt>
<dd><p>Return a sequence of string key names for all columns in this collection.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.update">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>update(iter_: Any) â NoReturn<a href="#sqlalchemy.sql.expression.ColumnCollection.update">Â¶</a></dt>
<dd><p>Dictionary update() is not implemented for <a href="#sqlalchemy.sql.expression.ColumnCollection">ColumnCollection</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnCollection.values">
method <a href="#sqlalchemy.sql.expression.ColumnCollection">sqlalchemy.sql.expression.ColumnCollection.</a>values() â List[_COL_co]<a href="#sqlalchemy.sql.expression.ColumnCollection.values">Â¶</a></dt>
<dd><p>Return a sequence of <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> or <a href="metadata.html#sqlalchemy.schema.Column">Column</a> objects for all columns in this collection.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement">
class sqlalchemy.sql.expression.ColumnElement<a href="#sqlalchemy.sql.expression.ColumnElement">Â¶</a></dt>
<dd><p>Represent a column-oriented SQL expression suitable for usage in the âcolumnsâ clause, WHERE clause etc. of a statement.</p>
<p>While the most familiar kind of <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> is the <a href="metadata.html#sqlalchemy.schema.Column">Column</a> object, <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
serves as the basis for any unit that may be present in a SQL expression, including the expressions themselves, SQL functions, bound parameters, literal expressions, keywords such as NULL, etc.
<a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
is the ultimate base class for all such elements.</p>
<p>A wide variety of SQLAlchemy Core functions work at the SQL expression level, and are intended to accept instances of <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> as arguments. These functions will typically document that they accept a âSQL expressionâ as an argument. What this means in terms of SQLAlchemy usually refers to an input which is either already in the form of a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> object, or a value which can be coerced into one. The coercion rules followed by most, but not all, SQLAlchemy Core functions with regards to SQL expressions are as follows:</p>
<ul>
<li><p>a literal Python value, such as a string, integer or floating point value, boolean, datetime, Decimal object, or virtually any other Python object, will be coerced into a âliteral bound valueâ. This generally means that a <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> will be produced featuring the given value embedded into the construct; the resulting <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> object is an instance of <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>.
The Python value will ultimately be sent to the DBAPI at execution time as a parameterized argument to the execute() or executemany() methods, after SQLAlchemy type-specific converters (e.g. those provided by any associated <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> objects) are applied to the value.</p></li>
<li><p>any special object value, typically ORM-level constructs, which feature an accessor called __clause_element__(). The Core expression system looks for this method when an object of otherwise unknown type is passed to a function that is looking to coerce the argument into a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> and sometimes a <a href="selectable.html#sqlalchemy.sql.expression.SelectBase">SelectBase</a> expression.
It is used within the ORM to convert from ORM-specific objects like mapped classes and mapped attributes into Core expression objects.</p></li>
<li><p>The Python None value is typically interpreted as NULL, which in SQLAlchemy Core produces an instance of <a href="#sqlalchemy.sql.expression.null">null()</a>.</p></li>
</ul>
<p>A <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> provides the ability to generate new <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
objects using Python expressions. This means that Python operators such as ==, != and &lt; are overloaded to mimic SQL operations, and allow the instantiation of further <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
instances which are composed from other, more fundamental <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
objects. For example, two <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> objects can be added together with the addition operator + to produce a <a href="#sqlalchemy.sql.expression.BinaryExpression">BinaryExpression</a>.
Both <a href="#sqlalchemy.sql.expression.ColumnClause">ColumnClause</a> and <a href="#sqlalchemy.sql.expression.BinaryExpression">BinaryExpression</a> are subclasses of <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>:</p>
<pre>&gt;&gt;&gt; from sqlalchemy.sql import column
&gt;&gt;&gt; column('a') + column('b')
&lt;sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0&gt;
&gt;&gt;&gt; print(column('a') + column('b'))
a + b
</pre>
<p>See also</p>
<p><a href="metadata.html#sqlalchemy.schema.Column">Column</a></p>
<p><a href="#sqlalchemy.sql.expression.column">column()</a></p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.ColumnElement.__eq__">__eq__()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.__le__">__le__()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.__lt__">__lt__()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.__ne__">__ne__()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.all_">all_()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.allows_lambda">allows_lambda</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.anon_key_label">anon_key_label</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.anon_label">anon_label</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.any_">any_()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.asc">asc()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.base_columns">base_columns</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.between">between()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_and">bitwise_and()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_lshift">bitwise_lshift()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_not">bitwise_not()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_or">bitwise_or()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_rshift">bitwise_rshift()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_xor">bitwise_xor()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.bool_op">bool_op()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.cast">cast()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.collate">collate()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.comparator">comparator</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.compare">compare()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.compile">compile()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.concat">concat()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.contains">contains()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.desc">desc()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.description">description</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.distinct">distinct()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.endswith">endswith()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.entity_namespace">entity_namespace</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.expression">expression</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.foreign_keys">foreign_keys</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.get_children">get_children()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.icontains">icontains()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.iendswith">iendswith()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.ilike">ilike()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.in_">in_()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.inherit_cache">inherit_cache</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.is_">is_()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.is_clause_element">is_clause_element</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.is_distinct_from">is_distinct_from()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.is_dml">is_dml</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.is_not">is_not()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.is_not_distinct_from">is_not_distinct_from()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.is_selectable">is_selectable</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.isnot">isnot()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.isnot_distinct_from">isnot_distinct_from()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.istartswith">istartswith()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.key">key</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.label">label()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.like">like()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.match">match()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.negation_clause">negation_clause</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.not_ilike">not_ilike()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.not_in">not_in()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.not_like">not_like()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.notilike">notilike()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.notin_">notin_()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.notlike">notlike()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.nulls_first">nulls_first()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.nulls_last">nulls_last()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.nullsfirst">nullsfirst()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.nullslast">nullslast()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.op">op()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.operate">operate()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.params">params()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.primary_key">primary_key</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.proxy_set">proxy_set</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.regexp_match">regexp_match()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.regexp_replace">regexp_replace()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.reverse_operate">reverse_operate()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.self_group">self_group()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.shares_lineage">shares_lineage()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.startswith">startswith()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.stringify_dialect">stringify_dialect</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.supports_execution">supports_execution</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.timetuple">timetuple</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.type">type</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.unique_params">unique_params()</a>, <a href="#sqlalchemy.sql.expression.ColumnElement.uses_inspection">uses_inspection</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a> (sqlalchemy.sql.roles.ColumnArgumentOrKeyRole, sqlalchemy.sql.roles.StatementOptionRole, sqlalchemy.sql.roles.WhereHavingRole, sqlalchemy.sql.roles.BinaryElementRole, sqlalchemy.sql.roles.OrderByRole, sqlalchemy.sql.roles.ColumnsClauseRole, sqlalchemy.sql.roles.LimitOffsetRole, sqlalchemy.sql.roles.DMLColumnRole, sqlalchemy.sql.roles.DDLConstraintColumnRole, sqlalchemy.sql.roles.DDLExpressionRole, <a href="#sqlalchemy.sql.expression.SQLColumnExpression">sqlalchemy.sql.expression.SQLColumnExpression</a>, sqlalchemy.sql.expression.DQLDMLClauseElement)</p>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.__eq__">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>__eq__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.__eq__">Â¶</a></dt>
<dd>
<p>inherited from the sqlalchemy.sql.expression.ColumnOperators.__eq__ method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the == operator.</p>
<p>In a column context, produces the clause a = b.
If the target is None, produces a IS NULL.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.__le__">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>__le__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.__le__">Â¶</a></dt>
<dd>
<p>inherited from the sqlalchemy.sql.expression.ColumnOperators.__le__ method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the &lt;= operator.</p>
<p>In a column context, produces the clause a &lt;= b.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.__lt__">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>__lt__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.__lt__">Â¶</a></dt>
<dd>
<p>inherited from the sqlalchemy.sql.expression.ColumnOperators.__lt__ method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the &lt; operator.</p>
<p>In a column context, produces the clause a &lt; b.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.__ne__">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>__ne__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.__ne__">Â¶</a></dt>
<dd>
<p>inherited from the sqlalchemy.sql.expression.ColumnOperators.__ne__ method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the != operator.</p>
<p>In a column context, produces the clause a != b.
If the target is None, produces a IS NOT NULL.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.all_">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>all_() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.all_">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.all_">ColumnOperators.all_()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce an <a href="#sqlalchemy.sql.expression.all_">all_()</a> clause against the parent object.</p>
<p>See the documentation for <a href="#sqlalchemy.sql.expression.all_">all_()</a> for examples.</p>
<p>Note</p>
<p>be sure to not confuse the newer <a href="#sqlalchemy.sql.expression.ColumnOperators.all_">ColumnOperators.all_()</a> method with the legacy version of this method, the <a href="type_basics.html#sqlalchemy.types.ARRAY.Comparator.all">Comparator.all()</a>
method thatâs specific to <a href="type_basics.html#sqlalchemy.types.ARRAY">ARRAY</a>, which uses a different calling style.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.allows_lambda">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>allows_lambda = True<a href="#sqlalchemy.sql.expression.ColumnElement.allows_lambda">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.anon_key_label">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>anon_key_label<a href="#sqlalchemy.sql.expression.ColumnElement.anon_key_label">Â¶</a></dt>
<dd>
<p>Deprecated since version 1.4: The <a href="#sqlalchemy.sql.expression.ColumnElement.anon_key_label">ColumnElement.anon_key_label</a> attribute is now private, and the public accessor is deprecated.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.anon_label">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>anon_label<a href="#sqlalchemy.sql.expression.ColumnElement.anon_label">Â¶</a></dt>
<dd>
<p>Deprecated since version 1.4: The <a href="#sqlalchemy.sql.expression.ColumnElement.anon_label">ColumnElement.anon_label</a> attribute is now private, and the public accessor is deprecated.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.any_">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>any_() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.any_">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.any_">ColumnOperators.any_()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce an <a href="#sqlalchemy.sql.expression.any_">any_()</a> clause against the parent object.</p>
<p>See the documentation for <a href="#sqlalchemy.sql.expression.any_">any_()</a> for examples.</p>
<p>Note</p>
<p>be sure to not confuse the newer <a href="#sqlalchemy.sql.expression.ColumnOperators.any_">ColumnOperators.any_()</a> method with the legacy version of this method, the <a href="type_basics.html#sqlalchemy.types.ARRAY.Comparator.any">Comparator.any()</a>
method thatâs specific to <a href="type_basics.html#sqlalchemy.types.ARRAY">ARRAY</a>, which uses a different calling style.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.asc">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>asc() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.asc">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.asc">ColumnOperators.asc()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a <a href="#sqlalchemy.sql.expression.asc">asc()</a> clause against the parent object.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.base_columns">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>base_columns<a href="#sqlalchemy.sql.expression.ColumnElement.base_columns">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.between">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>between(cleft: Any, cright: Any, symmetric: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.between">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.between">ColumnOperators.between()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a <a href="#sqlalchemy.sql.expression.between">between()</a> clause against the parent object, given the lower and upper range.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.bitwise_and">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>bitwise_and(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_and">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_and">ColumnOperators.bitwise_and()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a bitwise AND operation, typically via the &amp; operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.bitwise_lshift">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>bitwise_lshift(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_lshift">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift">ColumnOperators.bitwise_lshift()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a bitwise LSHIFT operation, typically via the &lt;&lt;
operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.bitwise_not">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>bitwise_not() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_not">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_not">ColumnOperators.bitwise_not()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a bitwise NOT operation, typically via the ~
operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.bitwise_or">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>bitwise_or(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_or">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_or">ColumnOperators.bitwise_or()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a bitwise OR operation, typically via the |
operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.bitwise_rshift">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>bitwise_rshift(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_rshift">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift">ColumnOperators.bitwise_rshift()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a bitwise RSHIFT operation, typically via the &gt;&gt;
operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.bitwise_xor">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>bitwise_xor(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.bitwise_xor">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor">ColumnOperators.bitwise_xor()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a bitwise XOR operation, typically via the ^
operator, or # for PostgreSQL.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.bool_op">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>bool_op(opstring: str, precedence: int = 0, python_impl: Callable[[...], Any] | None = None) â Callable[[Any], <a href="#sqlalchemy.sql.expression.Operators">Operators</a>]<a href="#sqlalchemy.sql.expression.ColumnElement.bool_op">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a> method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Return a custom boolean operator.</p>
<p>This method is shorthand for calling <a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a> and passing the <a href="#sqlalchemy.sql.expression.Operators.op.params.is_comparison">Operators.op.is_comparison</a>
flag with True. A key advantage to using <a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a>
is that when using column constructs, the âbooleanâ nature of the returned expression will be present for <a href="https://peps.python.org/pep-0484/">PEP 484</a> purposes.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.cast">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>cast(type_: _TypeEngineArgument[_OPT]) â <a href="#sqlalchemy.sql.expression.Cast">Cast</a>[_OPT]<a href="#sqlalchemy.sql.expression.ColumnElement.cast">Â¶</a></dt>
<dd><p>Produce a type cast, i.e. CAST(&lt;expression&gt; AS &lt;type&gt;).</p>
<p>This is a shortcut to the <a href="#sqlalchemy.sql.expression.cast">cast()</a> function.</p>
<p>See also</p>
<p><a href="../tutorial/data_select.html#tutorial-casts">Data Casts and Type Coercion</a></p>
<p><a href="#sqlalchemy.sql.expression.cast">cast()</a></p>
<p><a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.collate">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>collate(collation: str) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.collate">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.collate">ColumnOperators.collate()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a <a href="#sqlalchemy.sql.expression.collate">collate()</a> clause against the parent object, given the collation string.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.collate">collate()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.comparator">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>comparator<a href="#sqlalchemy.sql.expression.ColumnElement.comparator">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.compare">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>compare(other: <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>, **kw: Any) â bool<a href="#sqlalchemy.sql.expression.ColumnElement.compare">Â¶</a></dt>
<dd>
<p>inherited from the <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement.compare">ClauseElement.compare()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a></p>
<p>Compare this <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a> to the given <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>.</p>
<p>Subclasses should override the default behavior, which is a straight identity comparison.</p>
<p>**kw are arguments consumed by subclass compare() methods and may be used to modify the criteria for comparison (see <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>).</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.compile">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>compile(bind: _HasDialect | None = None, dialect: <a href="internals.html#sqlalchemy.engine.Dialect">Dialect</a> | None = None, **kw: Any) â <a href="internals.html#sqlalchemy.engine.Compiled">Compiled</a><a href="#sqlalchemy.sql.expression.ColumnElement.compile">Â¶</a></dt>
<dd>
<p>inherited from the CompilerElement.compile() method of CompilerElement</p>
<p>Compile this SQL expression.</p>
<p>The return value is a <a href="internals.html#sqlalchemy.engine.Compiled">Compiled</a> object.
Calling str() or unicode() on the returned value will yield a string representation of the result. The <a href="internals.html#sqlalchemy.engine.Compiled">Compiled</a> object also can return a dictionary of bind parameter names and values using the params accessor.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>bind<a href="#sqlalchemy.sql.expression.ColumnElement.compile.params.bind">Â¶</a> â An <a href="connections.html#sqlalchemy.engine.Connection">Connection</a> or <a href="connections.html#sqlalchemy.engine.Engine">Engine</a> which can provide a <a href="internals.html#sqlalchemy.engine.Dialect">Dialect</a> in order to generate a <a href="internals.html#sqlalchemy.engine.Compiled">Compiled</a> object. If the bind and dialect parameters are both omitted, a default SQL compiler is used.</p></li>
<li><p>column_keys<a href="#sqlalchemy.sql.expression.ColumnElement.compile.params.column_keys">Â¶</a> â Used for INSERT and UPDATE statements, a list of column names which should be present in the VALUES clause of the compiled statement. If None, all columns from the target table object are rendered.</p></li>
<li><p>dialect<a href="#sqlalchemy.sql.expression.ColumnElement.compile.params.dialect">Â¶</a> â A <a href="internals.html#sqlalchemy.engine.Dialect">Dialect</a> instance which can generate a <a href="internals.html#sqlalchemy.engine.Compiled">Compiled</a> object. This argument takes precedence over the bind argument.</p></li>
<li><p>compile_kwargs<a href="#sqlalchemy.sql.expression.ColumnElement.compile.params.compile_kwargs">Â¶</a> â <p>optional dictionary of additional parameters that will be passed through to the compiler within all âvisitâ
methods. This allows any custom flag to be passed through to a custom compilation construct, for example. It is also used for the case of passing the literal_binds flag through:</p>
<pre>from sqlalchemy.sql import table, column, select t = table('t', column('x'))
s = select(t).where(t.c.x == 5)
print(s.compile(compile_kwargs={"literal_binds": True}))</pre>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="../faq/sqlexpressions.html#faq-sql-expression-string">How do I render SQL expressions as strings, possibly with bound parameters inlined?</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.concat">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>concat(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.concat">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.concat">ColumnOperators.concat()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the âconcatâ operator.</p>
<p>In a column context, produces the clause a || b, or uses the concat() operator on MySQL.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.contains">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>contains(other: Any, **kw: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.contains">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the âcontainsâ operator.</p>
<p>Produces a LIKE expression that tests against a match for the middle of a string value:</p>
<pre>column LIKE '%' || &lt;other&gt; || '%'</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.contains("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape">ColumnOperators.contains.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.escape">ColumnOperators.contains.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnElement.contains.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape">ColumnOperators.contains.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnElement.contains.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.contains("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE '%' || :param || '%' ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnElement.contains.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.contains("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE '%' || :param || '%' ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape">ColumnOperators.contains.autoescape</a>:</p>
<pre>somecolumn.contains("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.desc">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>desc() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.desc">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.desc">ColumnOperators.desc()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a <a href="#sqlalchemy.sql.expression.desc">desc()</a> clause against the parent object.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.description">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>description<a href="#sqlalchemy.sql.expression.ColumnElement.description">Â¶</a></dt>
<dd>
<p>inherited from the ClauseElement.description attribute of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.distinct">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>distinct() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.distinct">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.distinct">ColumnOperators.distinct()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a <a href="#sqlalchemy.sql.expression.distinct">distinct()</a> clause against the parent object.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.endswith">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>endswith(other: Any, escape: str | None = None, autoescape: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.endswith">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the âendswithâ operator.</p>
<p>Produces a LIKE expression that tests against a match for the end of a string value:</p>
<pre>column LIKE '%' || &lt;other&gt;</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.endswith("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape">ColumnOperators.endswith.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.escape">ColumnOperators.endswith.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnElement.endswith.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape">ColumnOperators.endswith.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnElement.endswith.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.endswith("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE '%' || :param ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnElement.endswith.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.endswith("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE '%' || :param ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape">ColumnOperators.endswith.autoescape</a>:</p>
<pre>somecolumn.endswith("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.entity_namespace">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>entity_namespace<a href="#sqlalchemy.sql.expression.ColumnElement.entity_namespace">Â¶</a></dt>
<dd>
<p>inherited from the ClauseElement.entity_namespace attribute of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.expression">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>expression<a href="#sqlalchemy.sql.expression.ColumnElement.expression">Â¶</a></dt>
<dd><p>Return a column expression.</p>
<p>Part of the inspection interface; returns self.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.foreign_keys">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>foreign_keys: AbstractSet[<a href="constraints.html#sqlalchemy.schema.ForeignKey">ForeignKey</a>] = frozenset({})<a href="#sqlalchemy.sql.expression.ColumnElement.foreign_keys">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.get_children">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>get_children(*, omit_attrs: Tuple[str, ...] = (), **kw: Any) â Iterable[HasTraverseInternals]<a href="#sqlalchemy.sql.expression.ColumnElement.get_children">Â¶</a></dt>
<dd>
<p>inherited from the HasTraverseInternals.get_children() method of HasTraverseInternals</p>
<p>Return immediate child HasTraverseInternals elements of this HasTraverseInternals.</p>
<p>This is used for visit traversal.</p>
<p>**kw may contain flags that change the collection that is returned, for example to return a subset of items in order to cut down on larger traversals, or to return child items from a different context (such as schema-level collections instead of clause-level).</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.icontains">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>icontains(other: Any, **kw: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.icontains">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.icontains">ColumnOperators.icontains()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the icontains operator, e.g. case insensitive version of <a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a>.</p>
<p>Produces a LIKE expression that tests against an insensitive match for the middle of a string value:</p>
<pre>lower(column) LIKE '%' || lower(&lt;other&gt;) || '%'</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.icontains("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape">ColumnOperators.icontains.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.icontains.params.escape">ColumnOperators.icontains.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnElement.icontains.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape">ColumnOperators.icontains.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnElement.icontains.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.icontains("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnElement.icontains.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.icontains("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape">ColumnOperators.contains.autoescape</a>:</p>
<pre>somecolumn.icontains("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.iendswith">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>iendswith(other: Any, escape: str | None = None, autoescape: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.iendswith">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith">ColumnOperators.iendswith()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the iendswith operator, e.g. case insensitive version of <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a>.</p>
<p>Produces a LIKE expression that tests against an insensitive match for the end of a string value:</p>
<pre>lower(column) LIKE '%' || lower(&lt;other&gt;)</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.iendswith("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape">ColumnOperators.iendswith.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.escape">ColumnOperators.iendswith.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnElement.iendswith.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape">ColumnOperators.iendswith.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnElement.iendswith.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.iendswith("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnElement.iendswith.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.iendswith("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape">ColumnOperators.iendswith.autoescape</a>:</p>
<pre>somecolumn.endswith("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.ilike">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>ilike(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.ilike">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the ilike operator, e.g. case insensitive LIKE.</p>
<p>In a column context, produces an expression either of the form:</p>
<pre>lower(a) LIKE lower(other)</pre>
<p>Or on backends that support the ILIKE operator:</p>
<pre>a ILIKE other</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.ilike("%foobar%"))</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnElement.ilike.params.other">Â¶</a> â expression to be compared</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnElement.ilike.params.escape">Â¶</a> â <p>optional escape character, renders the ESCAPE keyword, e.g.:</p>
<pre>somecolumn.ilike("foo/%bar", escape="/")</pre>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.in_">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>in_(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.in_">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the in operator.</p>
<p>In a column context, produces the clause column IN &lt;other&gt;.</p>
<p>The given parameter other may be:</p>
<ul>
<li><p>A list of literal values, e.g.:</p>
<pre>stmt.where(column.in_([1, 2, 3]))</pre>
<p>In this calling form, the list of items is converted to a set of bound parameters the same length as the list given:</p>
<pre>WHERE COL IN (?, ?, ?)</pre>
</li>
<li><p>A list of tuples may be provided if the comparison is against a <a href="#sqlalchemy.sql.expression.tuple_">tuple_()</a> containing multiple expressions:</p>
<pre>from sqlalchemy import tuple_
stmt.where(tuple_(col1, col2).in_([(1, 10), (2, 20), (3, 30)]))</pre>
</li>
<li><p>An empty list, e.g.:</p>
<pre>stmt.where(column.in_([]))</pre>
<p>In this calling form, the expression renders an âempty setâ
expression. These expressions are tailored to individual backends and are generally trying to get an empty SELECT statement as a subquery. Such as on SQLite, the expression is:</p>
<pre>WHERE col IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)</pre>
<p>Changed in version 1.4: empty IN expressions now use an execution-time generated SELECT subquery in all cases.</p>
</li>
<li><p>A bound parameter, e.g. <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a>, may be used if it includes the <a href="#sqlalchemy.sql.expression.bindparam.params.expanding">bindparam.expanding</a> flag:</p>
<pre>stmt.where(column.in_(bindparam('value', expanding=True)))</pre>
<p>In this calling form, the expression renders a special non-SQL placeholder expression that looks like:</p>
<pre>WHERE COL IN ([EXPANDING_value])</pre>
<p>This placeholder expression is intercepted at statement execution time to be converted into the variable number of bound parameter form illustrated earlier. If the statement were executed as:</p>
<pre>connection.execute(stmt, {"value": [1, 2, 3]})</pre>
<p>The database would be passed a bound parameter for each value:</p>
<pre>WHERE COL IN (?, ?, ?)</pre>
<p>New in version 1.2: added âexpandingâ bound parameters</p>
<p>If an empty list is passed, a special âempty listâ expression, which is specific to the database in use, is rendered. On SQLite this would be:</p>
<pre>WHERE COL IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)</pre>
<p>New in version 1.3: âexpandingâ bound parameters now support empty lists</p>
</li>
<li><p>a <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a> construct, which is usually a correlated scalar select:</p>
<pre>stmt.where(
column.in_(
select(othertable.c.y).
where(table.c.x == othertable.c.x)
)
)</pre>
<p>In this calling form, <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a> renders as given:</p>
<pre>WHERE COL IN (SELECT othertable.y
FROM othertable WHERE othertable.x = table.x)</pre>
</li>
</ul>
<dl>
<dt>Parameters:</dt>
<dd><p>other<a href="#sqlalchemy.sql.expression.ColumnElement.in_.params.other">Â¶</a> â a list of literals, a <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
construct, or a <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> construct that includes the <a href="#sqlalchemy.sql.expression.bindparam.params.expanding">bindparam.expanding</a> flag set to True.</p>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.inherit_cache">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>inherit_cache: bool | None = None<a href="#sqlalchemy.sql.expression.ColumnElement.inherit_cache">Â¶</a></dt>
<dd>
<p>inherited from the HasCacheKey.inherit_cache attribute of <a href="foundation.html#sqlalchemy.sql.traversals.HasCacheKey">HasCacheKey</a></p>
<p>Indicate if this <a href="foundation.html#sqlalchemy.sql.traversals.HasCacheKey">HasCacheKey</a> instance should make use of the cache key generation scheme used by its immediate superclass.</p>
<p>The attribute defaults to None, which indicates that a construct has not yet taken into account whether or not its appropriate for it to participate in caching; this is functionally equivalent to setting the value to False, except that a warning is also emitted.</p>
<p>This flag can be set to True on a particular class, if the SQL that corresponds to the object does not change based on attributes which are local to this class, and not its superclass.</p>
<p>See also</p>
<p><a href="compiler.html#compilerext-caching">Enabling Caching Support for Custom Constructs</a> - General guideslines for setting the <a href="foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache">HasCacheKey.inherit_cache</a> attribute for third-party or user defined SQL constructs.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.is_">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>is_(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.is_">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.is_">ColumnOperators.is_()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the IS operator.</p>
<p>Normally, IS is generated automatically when comparing to a value of None, which resolves to NULL. However, explicit usage of IS may be desirable if comparing to boolean values on certain platforms.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.is_not">ColumnOperators.is_not()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.is_clause_element">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>is_clause_element = True<a href="#sqlalchemy.sql.expression.ColumnElement.is_clause_element">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.is_distinct_from">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>is_distinct_from(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.is_distinct_from">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from">ColumnOperators.is_distinct_from()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the IS DISTINCT FROM operator.</p>
<p>Renders âa IS DISTINCT FROM bâ on most platforms; on some such as SQLite may render âa IS NOT bâ.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.is_dml">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>is_dml = False<a href="#sqlalchemy.sql.expression.ColumnElement.is_dml">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.is_not">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>is_not(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.is_not">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.is_not">ColumnOperators.is_not()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the IS NOT operator.</p>
<p>Normally, IS NOT is generated automatically when comparing to a value of None, which resolves to NULL. However, explicit usage of IS NOT may be desirable if comparing to boolean values on certain platforms.</p>
<p>Changed in version 1.4: The is_not() operator is renamed from isnot() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.is_">ColumnOperators.is_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.is_not_distinct_from">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>is_not_distinct_from(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.is_not_distinct_from">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from">ColumnOperators.is_not_distinct_from()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the IS NOT DISTINCT FROM operator.</p>
<p>Renders âa IS NOT DISTINCT FROM bâ on most platforms; on some such as SQLite may render âa IS bâ.</p>
<p>Changed in version 1.4: The is_not_distinct_from() operator is renamed from isnot_distinct_from() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.is_selectable">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>is_selectable = False<a href="#sqlalchemy.sql.expression.ColumnElement.is_selectable">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.isnot">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>isnot(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.isnot">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.isnot">ColumnOperators.isnot()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the IS NOT operator.</p>
<p>Normally, IS NOT is generated automatically when comparing to a value of None, which resolves to NULL. However, explicit usage of IS NOT may be desirable if comparing to boolean values on certain platforms.</p>
<p>Changed in version 1.4: The is_not() operator is renamed from isnot() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.is_">ColumnOperators.is_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.isnot_distinct_from">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>isnot_distinct_from(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.isnot_distinct_from">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from">ColumnOperators.isnot_distinct_from()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the IS NOT DISTINCT FROM operator.</p>
<p>Renders âa IS NOT DISTINCT FROM bâ on most platforms; on some such as SQLite may render âa IS bâ.</p>
<p>Changed in version 1.4: The is_not_distinct_from() operator is renamed from isnot_distinct_from() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.istartswith">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>istartswith(other: Any, escape: str | None = None, autoescape: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.istartswith">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith">ColumnOperators.istartswith()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the istartswith operator, e.g. case insensitive version of <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a>.</p>
<p>Produces a LIKE expression that tests against an insensitive match for the start of a string value:</p>
<pre>lower(column) LIKE lower(&lt;other&gt;) || '%'</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.istartswith("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape">ColumnOperators.istartswith.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.escape">ColumnOperators.istartswith.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnElement.istartswith.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape">ColumnOperators.istartswith.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnElement.istartswith.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.istartswith("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnElement.istartswith.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.istartswith("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape">ColumnOperators.istartswith.autoescape</a>:</p>
<pre>somecolumn.istartswith("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.key">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>key: str | None = None<a href="#sqlalchemy.sql.expression.ColumnElement.key">Â¶</a></dt>
<dd><p>The âkeyâ that in some circumstances refers to this object in a Python namespace.</p>
<p>This typically refers to the âkeyâ of the column as present in the .c collection of a selectable, e.g. sometable.c["somekey"] would return a <a href="metadata.html#sqlalchemy.schema.Column">Column</a> with a .key of âsomekeyâ.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.label">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>label(name: str | None) â <a href="#sqlalchemy.sql.expression.Label">Label</a>[_T]<a href="#sqlalchemy.sql.expression.ColumnElement.label">Â¶</a></dt>
<dd><p>Produce a column label, i.e. &lt;columnname&gt; AS &lt;name&gt;.</p>
<p>This is a shortcut to the <a href="#sqlalchemy.sql.expression.label">label()</a> function.</p>
<p>If ânameâ is None, an anonymous label name will be generated.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.like">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>like(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.like">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the like operator.</p>
<p>In a column context, produces the expression:</p>
<pre>a LIKE other</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.like("%foobar%"))</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnElement.like.params.other">Â¶</a> â expression to be compared</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnElement.like.params.escape">Â¶</a> â <p>optional escape character, renders the ESCAPE keyword, e.g.:</p>
<pre>somecolumn.like("foo/%bar", escape="/")</pre>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.match">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>match(other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.match">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.match">ColumnOperators.match()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implements a database-specific âmatchâ operator.</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.match">ColumnOperators.match()</a> attempts to resolve to a MATCH-like function or operator provided by the backend.
Examples include:</p>
<ul>
<li><p>PostgreSQL - renders x @@ plainto_tsquery(y)</p>
<p>Changed in version 2.0: plainto_tsquery() is used instead of to_tsquery() for PostgreSQL now; for compatibility with other forms, see <a href="../dialects/postgresql.html#postgresql-match">Full Text Search</a>.</p>
</li>
<li><p>MySQL - renders MATCH (x) AGAINST (y IN BOOLEAN MODE)</p>
<p>See also</p>
<p><a href="../dialects/mysql.html#sqlalchemy.dialects.mysql.match">match</a> - MySQL specific construct with additional features.</p>
</li>
<li><p>Oracle - renders CONTAINS(x, y)</p></li>
<li><p>other backends may provide special implementations.</p></li>
<li><p>Backends without any special implementation will emit the operator as âMATCHâ. This is compatible with SQLite, for example.</p></li>
</ul>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.negation_clause">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>negation_clause: <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>[bool]<a href="#sqlalchemy.sql.expression.ColumnElement.negation_clause">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.not_ilike">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>not_ilike(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.not_ilike">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.not_ilike">ColumnOperators.not_ilike()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>implement the NOT ILIKE operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a>, i.e. ~x.ilike(y).</p>
<p>Changed in version 1.4: The not_ilike() operator is renamed from notilike() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.not_in">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>not_in(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.not_in">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.not_in">ColumnOperators.not_in()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>implement the NOT IN operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a>, i.e. ~x.in_(y).</p>
<p>In the case that other is an empty sequence, the compiler produces an âempty not inâ expression. This defaults to the expression â1 = 1â to produce true in all cases. The <a href="engines.html#sqlalchemy.create_engine.params.empty_in_strategy">create_engine.empty_in_strategy</a> may be used to alter this behavior.</p>
<p>Changed in version 1.4: The not_in() operator is renamed from notin_() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>Changed in version 1.2: The <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a> and <a href="#sqlalchemy.sql.expression.ColumnOperators.not_in">ColumnOperators.not_in()</a> operators now produce a âstaticâ expression for an empty IN sequence by default.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.not_like">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>not_like(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.not_like">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.not_like">ColumnOperators.not_like()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>implement the NOT LIKE operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a>, i.e. ~x.like(y).</p>
<p>Changed in version 1.4: The not_like() operator is renamed from notlike() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.notilike">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>notilike(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.notilike">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.notilike">ColumnOperators.notilike()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>implement the NOT ILIKE operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a>, i.e. ~x.ilike(y).</p>
<p>Changed in version 1.4: The not_ilike() operator is renamed from notilike() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.notin_">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>notin_(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.notin_">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.notin_">ColumnOperators.notin_()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>implement the NOT IN operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a>, i.e. ~x.in_(y).</p>
<p>In the case that other is an empty sequence, the compiler produces an âempty not inâ expression. This defaults to the expression â1 = 1â to produce true in all cases. The <a href="engines.html#sqlalchemy.create_engine.params.empty_in_strategy">create_engine.empty_in_strategy</a> may be used to alter this behavior.</p>
<p>Changed in version 1.4: The not_in() operator is renamed from notin_() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>Changed in version 1.2: The <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a> and <a href="#sqlalchemy.sql.expression.ColumnOperators.not_in">ColumnOperators.not_in()</a> operators now produce a âstaticâ expression for an empty IN sequence by default.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.notlike">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>notlike(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.notlike">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.notlike">ColumnOperators.notlike()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>implement the NOT LIKE operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a>, i.e. ~x.like(y).</p>
<p>Changed in version 1.4: The not_like() operator is renamed from notlike() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.nulls_first">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>nulls_first() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.nulls_first">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_first">ColumnOperators.nulls_first()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a <a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> clause against the parent object.</p>
<p>Changed in version 1.4: The nulls_first() operator is renamed from nullsfirst() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.nulls_last">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>nulls_last() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.nulls_last">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_last">ColumnOperators.nulls_last()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a <a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a> clause against the parent object.</p>
<p>Changed in version 1.4: The nulls_last() operator is renamed from nullslast() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.nullsfirst">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>nullsfirst() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.nullsfirst">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.nullsfirst">ColumnOperators.nullsfirst()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a <a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> clause against the parent object.</p>
<p>Changed in version 1.4: The nulls_first() operator is renamed from nullsfirst() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.nullslast">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>nullslast() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.nullslast">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.nullslast">ColumnOperators.nullslast()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Produce a <a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a> clause against the parent object.</p>
<p>Changed in version 1.4: The nulls_last() operator is renamed from nullslast() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.op">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>op(opstring: str, precedence: int = 0, is_comparison: bool = False, return_type: Type[<a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>[Any]] | <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>[Any] | None = None, python_impl: Callable[..., Any] | None = None) â Callable[[Any], <a href="#sqlalchemy.sql.expression.Operators">Operators</a>]<a href="#sqlalchemy.sql.expression.ColumnElement.op">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a> method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Produce a generic operator function.</p>
<p>e.g.:</p>
<pre>somecolumn.op("*")(5)</pre>
<p>produces:</p>
<pre>somecolumn * 5</pre>
<p>This function can also be used to make bitwise operators explicit. For example:</p>
<pre>somecolumn.op('&amp;')(0xff)</pre>
<p>is a bitwise AND of the value in somecolumn.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>opstring<a href="#sqlalchemy.sql.expression.ColumnElement.op.params.opstring">Â¶</a> â a string which will be output as the infix operator between this element and the expression passed to the generated function.</p></li>
<li><p>precedence<a href="#sqlalchemy.sql.expression.ColumnElement.op.params.precedence">Â¶</a> â <p>precedence which the database is expected to apply to the operator in SQL expressions. This integer value acts as a hint for the SQL compiler to know when explicit parenthesis should be rendered around a particular operation. A lower number will cause the expression to be parenthesized when applied against another operator with higher precedence. The default value of 0 is lower than all operators except for the comma (,) and AS operators. A value of 100 will be higher or equal to all operators, and -100 will be lower than or equal to all operators.</p>
<p>See also</p>
<p><a href="../faq/sqlexpressions.html#faq-sql-expression-op-parenthesis">Iâm using op() to generate a custom operator and my parenthesis are not coming out correctly</a> - detailed description of how the SQLAlchemy SQL compiler renders parenthesis</p>
</p></li>
<li><p>is_comparison<a href="#sqlalchemy.sql.expression.ColumnElement.op.params.is_comparison">Â¶</a> â <p>legacy; if True, the operator will be considered as a âcomparisonâ operator, that is which evaluates to a boolean true/false value, like ==, &gt;, etc. This flag is provided so that ORM relationships can establish that the operator is a comparison operator when used in a custom join condition.</p>
<p>Using the is_comparison parameter is superseded by using the <a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a> method instead; this more succinct operator sets this parameter automatically, but also provides correct <a href="https://peps.python.org/pep-0484/">PEP 484</a> typing support as the returned object will express a âbooleanâ datatype, i.e. BinaryExpression[bool].</p>
</p></li>
<li><p>return_type<a href="#sqlalchemy.sql.expression.ColumnElement.op.params.return_type">Â¶</a> â a <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> class or object that will force the return type of an expression produced by this operator to be of that type. By default, operators that specify <a href="#sqlalchemy.sql.expression.Operators.op.params.is_comparison">Operators.op.is_comparison</a> will resolve to <a href="type_basics.html#sqlalchemy.types.Boolean">Boolean</a>, and those that do not will be of the same type as the left-hand operand.</p></li>
<li><p>python_impl<a href="#sqlalchemy.sql.expression.ColumnElement.op.params.python_impl">Â¶</a> â <p>an optional Python function that can evaluate two Python values in the same way as this operator works when run on the database server. Useful for in-Python SQL expression evaluation functions, such as for ORM hybrid attributes, and the ORM âevaluatorâ used to match objects in a session after a multi-row update or delete.</p>
<p>e.g.:</p>
<pre>&gt;&gt;&gt; expr = column('x').op('+', python_impl=lambda a, b: a + b)('y')</pre>
<p>The operator for the above expression will also work for non-SQL left and right objects:</p>
<pre>&gt;&gt;&gt; expr.operator(5, 10)
15</pre>
<p>New in version 2.0.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a></p>
<p><a href="custom_types.html#types-operators">Redefining and Creating New Operators</a></p>
<p><a href="../orm/join_conditions.html#relationship-custom-operator">Using custom operators in join conditions</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.operate">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>operate(op: OperatorType, *other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>[Any]<a href="#sqlalchemy.sql.expression.ColumnElement.operate">Â¶</a></dt>
<dd><p>Operate on an argument.</p>
<p>This is the lowest level of operation, raises NotImplementedError by default.</p>
<p>Overriding this on a subclass can allow common behavior to be applied to all operations.
For example, overriding <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a>
to apply func.lower() to the left and right side:</p>
<pre>class MyComparator(ColumnOperators):
def operate(self, op, other, **kwargs):
return op(func.lower(self), func.lower(other), **kwargs)</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>op<a href="#sqlalchemy.sql.expression.ColumnElement.operate.params.op">Â¶</a> â Operator callable.</p></li>
<li><p>*other<a href="#sqlalchemy.sql.expression.ColumnElement.operate.params.*other">Â¶</a> â the âotherâ side of the operation. Will be a single scalar for most operations.</p></li>
<li><p>**kwargs<a href="#sqlalchemy.sql.expression.ColumnElement.operate.params.**kwargs">Â¶</a> â modifiers. These may be passed by special operators such as <a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.params">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>params(_ClauseElement__optionaldict: Mapping[str, Any] | None = None, **kwargs: Any) â Self<a href="#sqlalchemy.sql.expression.ColumnElement.params">Â¶</a></dt>
<dd>
<p>inherited from the <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement.params">ClauseElement.params()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a></p>
<p>Return a copy with <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> elements replaced.</p>
<p>Returns a copy of this ClauseElement with <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a>
elements replaced with values taken from the given dictionary:</p>
<pre>&gt;&gt;&gt; clause = column('x') + bindparam('foo')
&gt;&gt;&gt; print(clause.compile().params)
{'foo':None}
&gt;&gt;&gt; print(clause.params({'foo':7}).compile().params)
{'foo':7}</pre>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.primary_key">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>primary_key: bool = False<a href="#sqlalchemy.sql.expression.ColumnElement.primary_key">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.proxy_set">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>proxy_set: util.generic_fn_descriptor[FrozenSet[Any]]<a href="#sqlalchemy.sql.expression.ColumnElement.proxy_set">Â¶</a></dt>
<dd><p>set of all columns we are proxying</p>
<p>as of 2.0 this is explicitly deannotated columns. previously it was effectively deannotated columns but wasnât enforced. annotated columns should basically not go into sets if at all possible because their hashing behavior is very non-performant.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.regexp_match">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>regexp_match(pattern: Any, flags: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.regexp_match">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match">ColumnOperators.regexp_match()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implements a database-specific âregexp matchâ operator.</p>
<p>E.g.:</p>
<pre>stmt = select(table.c.some_column).where(
table.c.some_column.regexp_match('^(b|c)')
)</pre>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match">ColumnOperators.regexp_match()</a> attempts to resolve to a REGEXP-like function or operator provided by the backend, however the specific regular expression syntax and flags available are not backend agnostic.</p>
<p>Examples include:</p>
<ul>
<li><p>PostgreSQL - renders x ~ y or x !~ y when negated.</p></li>
<li><p>Oracle - renders REGEXP_LIKE(x, y)</p></li>
<li><p>SQLite - uses SQLiteâs REGEXP placeholder operator and calls into the Python re.match() builtin.</p></li>
<li><p>other backends may provide special implementations.</p></li>
<li><p>Backends without any special implementation will emit the operator as âREGEXPâ or âNOT REGEXPâ. This is compatible with SQLite and MySQL, for example.</p></li>
</ul>
<p>Regular expression support is currently implemented for Oracle, PostgreSQL, MySQL and MariaDB. Partial support is available for SQLite. Support among third-party dialects may vary.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>pattern<a href="#sqlalchemy.sql.expression.ColumnElement.regexp_match.params.pattern">Â¶</a> â The regular expression pattern string or column clause.</p></li>
<li><p>flags<a href="#sqlalchemy.sql.expression.ColumnElement.regexp_match.params.flags">Â¶</a> â Any regular expression string flags to apply, passed as plain Python string only. These flags are backend specific.
Some backends, like PostgreSQL and MariaDB, may alternatively specify the flags as part of the pattern.
When using the ignore case flag âiâ in PostgreSQL, the ignore case regexp match operator ~* or !~* will be used.</p></li>
</ul>
</dd>
</dl>
<p>New in version 1.4.</p>
<p>Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error, the âflagsâ parameter previously accepted SQL expression objects such as column expressions in addition to plain Python strings. This implementation did not work correctly with caching and was removed; strings only should be passed for the âflagsâ
parameter, as these flags are rendered as literal inline values within SQL expressions.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace">ColumnOperators.regexp_replace()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.regexp_replace">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>regexp_replace(pattern: Any, replacement: Any, flags: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.regexp_replace">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace">ColumnOperators.regexp_replace()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implements a database-specific âregexp replaceâ operator.</p>
<p>E.g.:</p>
<pre>stmt = select(
table.c.some_column.regexp_replace(
'b(..)',
'XY',
flags='g'
)
)</pre>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace">ColumnOperators.regexp_replace()</a> attempts to resolve to a REGEXP_REPLACE-like function provided by the backend, that usually emit the function REGEXP_REPLACE(). However, the specific regular expression syntax and flags available are not backend agnostic.</p>
<p>Regular expression replacement support is currently implemented for Oracle, PostgreSQL, MySQL 8 or greater and MariaDB. Support among third-party dialects may vary.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>pattern<a href="#sqlalchemy.sql.expression.ColumnElement.regexp_replace.params.pattern">Â¶</a> â The regular expression pattern string or column clause.</p></li>
<li><p>pattern<a href="#sqlalchemy.sql.expression.ColumnElement.regexp_replace.params.pattern">Â¶</a> â The replacement string or column clause.</p></li>
<li><p>flags<a href="#sqlalchemy.sql.expression.ColumnElement.regexp_replace.params.flags">Â¶</a> â Any regular expression string flags to apply, passed as plain Python string only. These flags are backend specific.
Some backends, like PostgreSQL and MariaDB, may alternatively specify the flags as part of the pattern.</p></li>
</ul>
</dd>
</dl>
<p>New in version 1.4.</p>
<p>Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error, the âflagsâ parameter previously accepted SQL expression objects such as column expressions in addition to plain Python strings. This implementation did not work correctly with caching and was removed; strings only should be passed for the âflagsâ
parameter, as these flags are rendered as literal inline values within SQL expressions.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match">ColumnOperators.regexp_match()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.reverse_operate">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>reverse_operate(op: OperatorType, other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>[Any]<a href="#sqlalchemy.sql.expression.ColumnElement.reverse_operate">Â¶</a></dt>
<dd><p>Reverse operate on an argument.</p>
<p>Usage is the same as <a href="#sqlalchemy.sql.expression.ColumnElement.operate">operate()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.self_group">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>self_group(against: OperatorType | None = None) â <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>[Any]<a href="#sqlalchemy.sql.expression.ColumnElement.self_group">Â¶</a></dt>
<dd><p>Apply a âgroupingâ to this <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>.</p>
<p>This method is overridden by subclasses to return a âgroupingâ
construct, i.e. parenthesis. In particular itâs used by âbinaryâ
expressions to provide a grouping around themselves when placed into a larger expression, as well as by <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
constructs when placed into the FROM clause of another <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>. (Note that subqueries should be normally created using the <a href="selectable.html#sqlalchemy.sql.expression.Select.alias">Select.alias()</a> method, as many platforms require nested SELECT statements to be named).</p>
<p>As expressions are composed together, the application of <a href="#sqlalchemy.sql.expression.ColumnElement.self_group">self_group()</a> is automatic - end-user code should never need to use this method directly. Note that SQLAlchemyâs clause constructs take operator precedence into account -
so parenthesis might not be needed, for example, in an expression like x OR (y AND z) - AND takes precedence over OR.</p>
<p>The base <a href="#sqlalchemy.sql.expression.ColumnElement.self_group">self_group()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>
just returns self.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.shares_lineage">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>shares_lineage(othercolumn: <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>[Any]) â bool<a href="#sqlalchemy.sql.expression.ColumnElement.shares_lineage">Â¶</a></dt>
<dd><p>Return True if the given <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
has a common ancestor to this <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.startswith">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>startswith(other: Any, escape: str | None = None, autoescape: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnElement.startswith">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a> method of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Implement the startswith operator.</p>
<p>Produces a LIKE expression that tests against a match for the start of a string value:</p>
<pre>column LIKE &lt;other&gt; || '%'</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.startswith("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape">ColumnOperators.startswith.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.escape">ColumnOperators.startswith.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnElement.startswith.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape">ColumnOperators.startswith.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnElement.startswith.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.startswith("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE :param || '%' ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnElement.startswith.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.startswith("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE :param || '%' ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape">ColumnOperators.startswith.autoescape</a>:</p>
<pre>somecolumn.startswith("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.stringify_dialect">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>stringify_dialect = 'default'<a href="#sqlalchemy.sql.expression.ColumnElement.stringify_dialect">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.supports_execution">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>supports_execution = False<a href="#sqlalchemy.sql.expression.ColumnElement.supports_execution">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.timetuple">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>timetuple: Literal[None] = None<a href="#sqlalchemy.sql.expression.ColumnElement.timetuple">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.ColumnOperators.timetuple">ColumnOperators.timetuple</a> attribute of <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p>Hack, allows datetime objects to be compared on the LHS.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.type">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>type: <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>[_T]<a href="#sqlalchemy.sql.expression.ColumnElement.type">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.unique_params">
method <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>unique_params(_ClauseElement__optionaldict: Dict[str, Any] | None = None, **kwargs: Any) â Self<a href="#sqlalchemy.sql.expression.ColumnElement.unique_params">Â¶</a></dt>
<dd>
<p>inherited from the <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement.unique_params">ClauseElement.unique_params()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a></p>
<p>Return a copy with <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> elements replaced.</p>
<p>Same functionality as <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement.params">ClauseElement.params()</a>, except adds unique=True to affected bind parameters so that multiple statements can be used.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnElement.uses_inspection">
attribute <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement.</a>uses_inspection = True<a href="#sqlalchemy.sql.expression.ColumnElement.uses_inspection">Â¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnExpressionArgument">
sqlalchemy.sql.expression.ColumnExpressionArgument<a href="#sqlalchemy.sql.expression.ColumnExpressionArgument">Â¶</a></dt>
<dd><p>General purpose âcolumn expressionâ argument.</p>
<p>New in version 2.0.13.</p>
<p>This type is used for âcolumnâ kinds of expressions that typically represent a single SQL column expression, including <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>, as well as ORM-mapped attributes that will have a __clause_element__()
method.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators">
class sqlalchemy.sql.expression.ColumnOperators<a href="#sqlalchemy.sql.expression.ColumnOperators">Â¶</a></dt>
<dd><p>Defines boolean, comparison, and other operators for <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> expressions.</p>
<p>By default, all methods call down to <a href="#sqlalchemy.sql.expression.ColumnOperators.operate">operate()</a> or <a href="#sqlalchemy.sql.expression.ColumnOperators.reverse_operate">reverse_operate()</a>, passing in the appropriate operator function from the Python builtin operator module or a SQLAlchemy-specific operator function from sqlalchemy.expression.operators. For example the __eq__ function:</p>
<pre>def __eq__(self, other):
return self.operate(operators.eq, other)</pre>
<p>Where operators.eq is essentially:</p>
<pre>def eq(a, b):
return a == b</pre>
<p>The core column expression unit <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
overrides <a href="#sqlalchemy.sql.expression.Operators.operate">Operators.operate()</a> and others to return further <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> constructs, so that the == operation above is replaced by a clause construct.</p>
<p>See also</p>
<p><a href="custom_types.html#types-operators">Redefining and Creating New Operators</a></p>
<p><a href="type_api.html#sqlalchemy.types.TypeEngine.comparator_factory">TypeEngine.comparator_factory</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a></p>
<p><a href="../orm/internals.html#sqlalchemy.orm.PropComparator">PropComparator</a></p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.__add__">__add__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__and__">__and__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__eq__">__eq__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__floordiv__">__floordiv__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__ge__">__ge__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__getitem__">__getitem__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__gt__">__gt__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__hash__">__hash__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__invert__">__invert__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__le__">__le__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__lshift__">__lshift__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__lt__">__lt__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__mod__">__mod__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__mul__">__mul__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__ne__">__ne__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__neg__">__neg__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__or__">__or__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__radd__">__radd__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__">__rfloordiv__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__rmod__">__rmod__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__rmul__">__rmul__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__rshift__">__rshift__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__rsub__">__rsub__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__rtruediv__">__rtruediv__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__sa_operate__">__sa_operate__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__sub__">__sub__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.__truediv__">__truediv__()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.all_">all_()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.any_">any_()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.asc">asc()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.between">between()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_and">bitwise_and()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift">bitwise_lshift()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_not">bitwise_not()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_or">bitwise_or()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift">bitwise_rshift()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor">bitwise_xor()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.bool_op">bool_op()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.collate">collate()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.concat">concat()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.contains">contains()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.desc">desc()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.distinct">distinct()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">endswith()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.icontains">icontains()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith">iendswith()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ilike()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">in_()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.is_">is_()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from">is_distinct_from()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.is_not">is_not()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from">is_not_distinct_from()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.isnot">isnot()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from">isnot_distinct_from()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith">istartswith()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.like">like()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.match">match()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.not_ilike">not_ilike()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.not_in">not_in()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.not_like">not_like()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.notilike">notilike()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.notin_">notin_()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.notlike">notlike()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_first">nulls_first()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_last">nulls_last()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.nullsfirst">nullsfirst()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.nullslast">nullslast()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.op">op()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.operate">operate()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match">regexp_match()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace">regexp_replace()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.reverse_operate">reverse_operate()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">startswith()</a>, <a href="#sqlalchemy.sql.expression.ColumnOperators.timetuple">timetuple</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators</a> (<a href="#sqlalchemy.sql.expression.Operators">sqlalchemy.sql.expression.Operators</a>)</p>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__add__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__add__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__add__">Â¶</a></dt>
<dd><p>Implement the + operator.</p>
<p>In a column context, produces the clause a + b if the parent object has non-string affinity.
If the parent object has a string affinity, produces the concatenation operator, a || b -
see <a href="#sqlalchemy.sql.expression.ColumnOperators.concat">ColumnOperators.concat()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__and__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__and__(other: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__and__">Â¶</a></dt>
<dd>
<p>inherited from the sqlalchemy.sql.expression.Operators.__and__ method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Implement the &amp; operator.</p>
<p>When used with SQL expressions, results in an AND operation, equivalent to <a href="#sqlalchemy.sql.expression.and_">and_()</a>, that is:</p>
<pre>a &amp; b</pre>
<p>is equivalent to:</p>
<pre>from sqlalchemy import and_
and_(a, b)</pre>
<p>Care should be taken when using &amp; regarding operator precedence; the &amp; operator has the highest precedence.
The operands should be enclosed in parenthesis if they contain further sub expressions:</p>
<pre>(a == 2) &amp; (b == 4)</pre>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__eq__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__eq__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__eq__">Â¶</a></dt>
<dd><p>Implement the == operator.</p>
<p>In a column context, produces the clause a = b.
If the target is None, produces a IS NULL.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__floordiv__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__floordiv__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__floordiv__">Â¶</a></dt>
<dd><p>Implement the // operator.</p>
<p>In a column context, produces the clause a / b, which is the same as âtruedivâ, but considers the result type to be integer.</p>
<p>New in version 2.0.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__ge__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__ge__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__ge__">Â¶</a></dt>
<dd><p>Implement the &gt;= operator.</p>
<p>In a column context, produces the clause a &gt;= b.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__getitem__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__getitem__(index: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__getitem__">Â¶</a></dt>
<dd><p>Implement the [] operator.</p>
<p>This can be used by some database-specific types such as PostgreSQL ARRAY and HSTORE.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__gt__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__gt__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__gt__">Â¶</a></dt>
<dd><p>Implement the &gt; operator.</p>
<p>In a column context, produces the clause a &gt; b.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__hash__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__hash__()<a href="#sqlalchemy.sql.expression.ColumnOperators.__hash__">Â¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__invert__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__invert__() â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__invert__">Â¶</a></dt>
<dd>
<p>inherited from the sqlalchemy.sql.expression.Operators.__invert__ method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Implement the ~ operator.</p>
<p>When used with SQL expressions, results in a NOT operation, equivalent to <a href="#sqlalchemy.sql.expression.not_">not_()</a>, that is:</p>
<pre>~a</pre>
<p>is equivalent to:</p>
<pre>from sqlalchemy import not_
not_(a)</pre>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__le__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__le__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__le__">Â¶</a></dt>
<dd><p>Implement the &lt;= operator.</p>
<p>In a column context, produces the clause a &lt;= b.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__lshift__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__lshift__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__lshift__">Â¶</a></dt>
<dd><p>implement the &lt;&lt; operator.</p>
<p>Not used by SQLAlchemy core, this is provided for custom operator systems which want to use &lt;&lt; as an extension point.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__lt__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__lt__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__lt__">Â¶</a></dt>
<dd><p>Implement the &lt; operator.</p>
<p>In a column context, produces the clause a &lt; b.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__mod__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__mod__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__mod__">Â¶</a></dt>
<dd><p>Implement the % operator.</p>
<p>In a column context, produces the clause a % b.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__mul__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__mul__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__mul__">Â¶</a></dt>
<dd><p>Implement the * operator.</p>
<p>In a column context, produces the clause a * b.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__ne__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__ne__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__ne__">Â¶</a></dt>
<dd><p>Implement the != operator.</p>
<p>In a column context, produces the clause a != b.
If the target is None, produces a IS NOT NULL.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__neg__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__neg__() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__neg__">Â¶</a></dt>
<dd><p>Implement the - operator.</p>
<p>In a column context, produces the clause -a.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__or__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__or__(other: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__or__">Â¶</a></dt>
<dd>
<p>inherited from the sqlalchemy.sql.expression.Operators.__or__ method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Implement the | operator.</p>
<p>When used with SQL expressions, results in an OR operation, equivalent to <a href="#sqlalchemy.sql.expression.or_">or_()</a>, that is:</p>
<pre>a | b</pre>
<p>is equivalent to:</p>
<pre>from sqlalchemy import or_
or_(a, b)</pre>
<p>Care should be taken when using | regarding operator precedence; the | operator has the highest precedence.
The operands should be enclosed in parenthesis if they contain further sub expressions:</p>
<pre>(a == 2) | (b == 4)</pre>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__radd__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__radd__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__radd__">Â¶</a></dt>
<dd><p>Implement the + operator in reverse.</p>
<p>See <a href="#sqlalchemy.sql.expression.ColumnOperators.__add__">ColumnOperators.__add__()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__rfloordiv__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__">Â¶</a></dt>
<dd><p>Implement the // operator in reverse.</p>
<p>See <a href="#sqlalchemy.sql.expression.ColumnOperators.__floordiv__">ColumnOperators.__floordiv__()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__rmod__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__rmod__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__rmod__">Â¶</a></dt>
<dd><p>Implement the % operator in reverse.</p>
<p>See <a href="#sqlalchemy.sql.expression.ColumnOperators.__mod__">ColumnOperators.__mod__()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__rmul__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__rmul__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__rmul__">Â¶</a></dt>
<dd><p>Implement the * operator in reverse.</p>
<p>See <a href="#sqlalchemy.sql.expression.ColumnOperators.__mul__">ColumnOperators.__mul__()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__rshift__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__rshift__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__rshift__">Â¶</a></dt>
<dd><p>implement the &gt;&gt; operator.</p>
<p>Not used by SQLAlchemy core, this is provided for custom operator systems which want to use &gt;&gt; as an extension point.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__rsub__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__rsub__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__rsub__">Â¶</a></dt>
<dd><p>Implement the - operator in reverse.</p>
<p>See <a href="#sqlalchemy.sql.expression.ColumnOperators.__sub__">ColumnOperators.__sub__()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__rtruediv__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__rtruediv__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__rtruediv__">Â¶</a></dt>
<dd><p>Implement the / operator in reverse.</p>
<p>See <a href="#sqlalchemy.sql.expression.ColumnOperators.__truediv__">ColumnOperators.__truediv__()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__sa_operate__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__sa_operate__(op: OperatorType, *other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__sa_operate__">Â¶</a></dt>
<dd>
<p>inherited from the sqlalchemy.sql.expression.Operators.__sa_operate__ method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Operate on an argument.</p>
<p>This is the lowest level of operation, raises NotImplementedError by default.</p>
<p>Overriding this on a subclass can allow common behavior to be applied to all operations.
For example, overriding <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a>
to apply func.lower() to the left and right side:</p>
<pre>class MyComparator(ColumnOperators):
def operate(self, op, other, **kwargs):
return op(func.lower(self), func.lower(other), **kwargs)</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>op<a href="#sqlalchemy.sql.expression.ColumnOperators.__sa_operate__.params.op">Â¶</a> â Operator callable.</p></li>
<li><p>*other<a href="#sqlalchemy.sql.expression.ColumnOperators.__sa_operate__.params.*other">Â¶</a> â the âotherâ side of the operation. Will be a single scalar for most operations.</p></li>
<li><p>**kwargs<a href="#sqlalchemy.sql.expression.ColumnOperators.__sa_operate__.params.**kwargs">Â¶</a> â modifiers. These may be passed by special operators such as <a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__sub__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__sub__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__sub__">Â¶</a></dt>
<dd><p>Implement the - operator.</p>
<p>In a column context, produces the clause a - b.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.__truediv__">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>__truediv__(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.__truediv__">Â¶</a></dt>
<dd><p>Implement the / operator.</p>
<p>In a column context, produces the clause a / b, and considers the result type to be numeric.</p>
<p>Changed in version 2.0: The truediv operator against two integers is now considered to return a numeric value. Behavior on specific backends may vary.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.all_">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>all_() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.all_">Â¶</a></dt>
<dd><p>Produce an <a href="#sqlalchemy.sql.expression.all_">all_()</a> clause against the parent object.</p>
<p>See the documentation for <a href="#sqlalchemy.sql.expression.all_">all_()</a> for examples.</p>
<p>Note</p>
<p>be sure to not confuse the newer <a href="#sqlalchemy.sql.expression.ColumnOperators.all_">ColumnOperators.all_()</a> method with the legacy version of this method, the <a href="type_basics.html#sqlalchemy.types.ARRAY.Comparator.all">Comparator.all()</a>
method thatâs specific to <a href="type_basics.html#sqlalchemy.types.ARRAY">ARRAY</a>, which uses a different calling style.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.any_">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>any_() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.any_">Â¶</a></dt>
<dd><p>Produce an <a href="#sqlalchemy.sql.expression.any_">any_()</a> clause against the parent object.</p>
<p>See the documentation for <a href="#sqlalchemy.sql.expression.any_">any_()</a> for examples.</p>
<p>Note</p>
<p>be sure to not confuse the newer <a href="#sqlalchemy.sql.expression.ColumnOperators.any_">ColumnOperators.any_()</a> method with the legacy version of this method, the <a href="type_basics.html#sqlalchemy.types.ARRAY.Comparator.any">Comparator.any()</a>
method thatâs specific to <a href="type_basics.html#sqlalchemy.types.ARRAY">ARRAY</a>, which uses a different calling style.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.asc">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>asc() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.asc">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.asc">asc()</a> clause against the parent object.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.between">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>between(cleft: Any, cright: Any, symmetric: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.between">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.between">between()</a> clause against the parent object, given the lower and upper range.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.bitwise_and">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>bitwise_and(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_and">Â¶</a></dt>
<dd><p>Produce a bitwise AND operation, typically via the &amp; operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>bitwise_lshift(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift">Â¶</a></dt>
<dd><p>Produce a bitwise LSHIFT operation, typically via the &lt;&lt;
operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.bitwise_not">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>bitwise_not() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_not">Â¶</a></dt>
<dd><p>Produce a bitwise NOT operation, typically via the ~
operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.bitwise_or">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>bitwise_or(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_or">Â¶</a></dt>
<dd><p>Produce a bitwise OR operation, typically via the |
operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>bitwise_rshift(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift">Â¶</a></dt>
<dd><p>Produce a bitwise RSHIFT operation, typically via the &gt;&gt;
operator.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.bitwise_xor">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>bitwise_xor(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor">Â¶</a></dt>
<dd><p>Produce a bitwise XOR operation, typically via the ^
operator, or # for PostgreSQL.</p>
<p>New in version 2.0.2.</p>
<p>See also</p>
<p><a href="operators.html#operators-bitwise">Bitwise Operators</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.bool_op">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>bool_op(opstring: str, precedence: int = 0, python_impl: Callable[[...], Any] | None = None) â Callable[[Any], <a href="#sqlalchemy.sql.expression.Operators">Operators</a>]<a href="#sqlalchemy.sql.expression.ColumnOperators.bool_op">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a> method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Return a custom boolean operator.</p>
<p>This method is shorthand for calling <a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a> and passing the <a href="#sqlalchemy.sql.expression.Operators.op.params.is_comparison">Operators.op.is_comparison</a>
flag with True. A key advantage to using <a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a>
is that when using column constructs, the âbooleanâ nature of the returned expression will be present for <a href="https://peps.python.org/pep-0484/">PEP 484</a> purposes.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.collate">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>collate(collation: str) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.collate">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.collate">collate()</a> clause against the parent object, given the collation string.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.collate">collate()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.concat">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>concat(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.concat">Â¶</a></dt>
<dd><p>Implement the âconcatâ operator.</p>
<p>In a column context, produces the clause a || b, or uses the concat() operator on MySQL.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.contains">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>contains(other: Any, **kw: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.contains">Â¶</a></dt>
<dd><p>Implement the âcontainsâ operator.</p>
<p>Produces a LIKE expression that tests against a match for the middle of a string value:</p>
<pre>column LIKE '%' || &lt;other&gt; || '%'</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.contains("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape">ColumnOperators.contains.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.escape">ColumnOperators.contains.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape">ColumnOperators.contains.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.contains("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE '%' || :param || '%' ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.contains("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE '%' || :param || '%' ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape">ColumnOperators.contains.autoescape</a>:</p>
<pre>somecolumn.contains("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.desc">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>desc() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.desc">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.desc">desc()</a> clause against the parent object.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.distinct">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>distinct() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.distinct">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.distinct">distinct()</a> clause against the parent object.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.endswith">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>endswith(other: Any, escape: str | None = None, autoescape: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">Â¶</a></dt>
<dd><p>Implement the âendswithâ operator.</p>
<p>Produces a LIKE expression that tests against a match for the end of a string value:</p>
<pre>column LIKE '%' || &lt;other&gt;</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.endswith("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape">ColumnOperators.endswith.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.escape">ColumnOperators.endswith.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape">ColumnOperators.endswith.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.endswith("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE '%' || :param ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.endswith("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE '%' || :param ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape">ColumnOperators.endswith.autoescape</a>:</p>
<pre>somecolumn.endswith("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.icontains">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>icontains(other: Any, **kw: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.icontains">Â¶</a></dt>
<dd><p>Implement the icontains operator, e.g. case insensitive version of <a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a>.</p>
<p>Produces a LIKE expression that tests against an insensitive match for the middle of a string value:</p>
<pre>lower(column) LIKE '%' || lower(&lt;other&gt;) || '%'</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.icontains("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape">ColumnOperators.icontains.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.icontains.params.escape">ColumnOperators.icontains.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnOperators.icontains.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape">ColumnOperators.icontains.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.icontains("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnOperators.icontains.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.icontains("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape">ColumnOperators.contains.autoescape</a>:</p>
<pre>somecolumn.icontains("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.iendswith">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>iendswith(other: Any, escape: str | None = None, autoescape: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith">Â¶</a></dt>
<dd><p>Implement the iendswith operator, e.g. case insensitive version of <a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a>.</p>
<p>Produces a LIKE expression that tests against an insensitive match for the end of a string value:</p>
<pre>lower(column) LIKE '%' || lower(&lt;other&gt;)</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.iendswith("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape">ColumnOperators.iendswith.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.escape">ColumnOperators.iendswith.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape">ColumnOperators.iendswith.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.iendswith("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.iendswith("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape">ColumnOperators.iendswith.autoescape</a>:</p>
<pre>somecolumn.endswith("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.ilike">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>ilike(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">Â¶</a></dt>
<dd><p>Implement the ilike operator, e.g. case insensitive LIKE.</p>
<p>In a column context, produces an expression either of the form:</p>
<pre>lower(a) LIKE lower(other)</pre>
<p>Or on backends that support the ILIKE operator:</p>
<pre>a ILIKE other</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.ilike("%foobar%"))</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnOperators.ilike.params.other">Â¶</a> â expression to be compared</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnOperators.ilike.params.escape">Â¶</a> â <p>optional escape character, renders the ESCAPE keyword, e.g.:</p>
<pre>somecolumn.ilike("foo/%bar", escape="/")</pre>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.in_">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>in_(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.in_">Â¶</a></dt>
<dd><p>Implement the in operator.</p>
<p>In a column context, produces the clause column IN &lt;other&gt;.</p>
<p>The given parameter other may be:</p>
<ul>
<li><p>A list of literal values, e.g.:</p>
<pre>stmt.where(column.in_([1, 2, 3]))</pre>
<p>In this calling form, the list of items is converted to a set of bound parameters the same length as the list given:</p>
<pre>WHERE COL IN (?, ?, ?)</pre>
</li>
<li><p>A list of tuples may be provided if the comparison is against a <a href="#sqlalchemy.sql.expression.tuple_">tuple_()</a> containing multiple expressions:</p>
<pre>from sqlalchemy import tuple_
stmt.where(tuple_(col1, col2).in_([(1, 10), (2, 20), (3, 30)]))</pre>
</li>
<li><p>An empty list, e.g.:</p>
<pre>stmt.where(column.in_([]))</pre>
<p>In this calling form, the expression renders an âempty setâ
expression. These expressions are tailored to individual backends and are generally trying to get an empty SELECT statement as a subquery. Such as on SQLite, the expression is:</p>
<pre>WHERE col IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)</pre>
<p>Changed in version 1.4: empty IN expressions now use an execution-time generated SELECT subquery in all cases.</p>
</li>
<li><p>A bound parameter, e.g. <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a>, may be used if it includes the <a href="#sqlalchemy.sql.expression.bindparam.params.expanding">bindparam.expanding</a> flag:</p>
<pre>stmt.where(column.in_(bindparam('value', expanding=True)))</pre>
<p>In this calling form, the expression renders a special non-SQL placeholder expression that looks like:</p>
<pre>WHERE COL IN ([EXPANDING_value])</pre>
<p>This placeholder expression is intercepted at statement execution time to be converted into the variable number of bound parameter form illustrated earlier. If the statement were executed as:</p>
<pre>connection.execute(stmt, {"value": [1, 2, 3]})</pre>
<p>The database would be passed a bound parameter for each value:</p>
<pre>WHERE COL IN (?, ?, ?)</pre>
<p>New in version 1.2: added âexpandingâ bound parameters</p>
<p>If an empty list is passed, a special âempty listâ expression, which is specific to the database in use, is rendered. On SQLite this would be:</p>
<pre>WHERE COL IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)</pre>
<p>New in version 1.3: âexpandingâ bound parameters now support empty lists</p>
</li>
<li><p>a <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a> construct, which is usually a correlated scalar select:</p>
<pre>stmt.where(
column.in_(
select(othertable.c.y).
where(table.c.x == othertable.c.x)
)
)</pre>
<p>In this calling form, <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a> renders as given:</p>
<pre>WHERE COL IN (SELECT othertable.y
FROM othertable WHERE othertable.x = table.x)</pre>
</li>
</ul>
<dl>
<dt>Parameters:</dt>
<dd><p>other<a href="#sqlalchemy.sql.expression.ColumnOperators.in_.params.other">Â¶</a> â a list of literals, a <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
construct, or a <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> construct that includes the <a href="#sqlalchemy.sql.expression.bindparam.params.expanding">bindparam.expanding</a> flag set to True.</p>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.is_">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>is_(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.is_">Â¶</a></dt>
<dd><p>Implement the IS operator.</p>
<p>Normally, IS is generated automatically when comparing to a value of None, which resolves to NULL. However, explicit usage of IS may be desirable if comparing to boolean values on certain platforms.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.is_not">ColumnOperators.is_not()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.is_distinct_from">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>is_distinct_from(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from">Â¶</a></dt>
<dd><p>Implement the IS DISTINCT FROM operator.</p>
<p>Renders âa IS DISTINCT FROM bâ on most platforms; on some such as SQLite may render âa IS NOT bâ.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.is_not">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>is_not(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.is_not">Â¶</a></dt>
<dd><p>Implement the IS NOT operator.</p>
<p>Normally, IS NOT is generated automatically when comparing to a value of None, which resolves to NULL. However, explicit usage of IS NOT may be desirable if comparing to boolean values on certain platforms.</p>
<p>Changed in version 1.4: The is_not() operator is renamed from isnot() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.is_">ColumnOperators.is_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>is_not_distinct_from(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from">Â¶</a></dt>
<dd><p>Implement the IS NOT DISTINCT FROM operator.</p>
<p>Renders âa IS NOT DISTINCT FROM bâ on most platforms; on some such as SQLite may render âa IS bâ.</p>
<p>Changed in version 1.4: The is_not_distinct_from() operator is renamed from isnot_distinct_from() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.isnot">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>isnot(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.isnot">Â¶</a></dt>
<dd><p>Implement the IS NOT operator.</p>
<p>Normally, IS NOT is generated automatically when comparing to a value of None, which resolves to NULL. However, explicit usage of IS NOT may be desirable if comparing to boolean values on certain platforms.</p>
<p>Changed in version 1.4: The is_not() operator is renamed from isnot() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.is_">ColumnOperators.is_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>isnot_distinct_from(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from">Â¶</a></dt>
<dd><p>Implement the IS NOT DISTINCT FROM operator.</p>
<p>Renders âa IS NOT DISTINCT FROM bâ on most platforms; on some such as SQLite may render âa IS bâ.</p>
<p>Changed in version 1.4: The is_not_distinct_from() operator is renamed from isnot_distinct_from() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.istartswith">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>istartswith(other: Any, escape: str | None = None, autoescape: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith">Â¶</a></dt>
<dd><p>Implement the istartswith operator, e.g. case insensitive version of <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a>.</p>
<p>Produces a LIKE expression that tests against an insensitive match for the start of a string value:</p>
<pre>lower(column) LIKE lower(&lt;other&gt;) || '%'</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.istartswith("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape">ColumnOperators.istartswith.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.escape">ColumnOperators.istartswith.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape">ColumnOperators.istartswith.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.istartswith("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.istartswith("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape">ColumnOperators.istartswith.autoescape</a>:</p>
<pre>somecolumn.istartswith("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">ColumnOperators.startswith()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.like">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>like(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.like">Â¶</a></dt>
<dd><p>Implement the like operator.</p>
<p>In a column context, produces the expression:</p>
<pre>a LIKE other</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.like("%foobar%"))</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnOperators.like.params.other">Â¶</a> â expression to be compared</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnOperators.like.params.escape">Â¶</a> â <p>optional escape character, renders the ESCAPE keyword, e.g.:</p>
<pre>somecolumn.like("foo/%bar", escape="/")</pre>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.match">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>match(other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.match">Â¶</a></dt>
<dd><p>Implements a database-specific âmatchâ operator.</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.match">ColumnOperators.match()</a> attempts to resolve to a MATCH-like function or operator provided by the backend.
Examples include:</p>
<ul>
<li><p>PostgreSQL - renders x @@ plainto_tsquery(y)</p>
<p>Changed in version 2.0: plainto_tsquery() is used instead of to_tsquery() for PostgreSQL now; for compatibility with other forms, see <a href="../dialects/postgresql.html#postgresql-match">Full Text Search</a>.</p>
</li>
<li><p>MySQL - renders MATCH (x) AGAINST (y IN BOOLEAN MODE)</p>
<p>See also</p>
<p><a href="../dialects/mysql.html#sqlalchemy.dialects.mysql.match">match</a> - MySQL specific construct with additional features.</p>
</li>
<li><p>Oracle - renders CONTAINS(x, y)</p></li>
<li><p>other backends may provide special implementations.</p></li>
<li><p>Backends without any special implementation will emit the operator as âMATCHâ. This is compatible with SQLite, for example.</p></li>
</ul>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.not_ilike">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>not_ilike(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.not_ilike">Â¶</a></dt>
<dd><p>implement the NOT ILIKE operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a>, i.e. ~x.ilike(y).</p>
<p>Changed in version 1.4: The not_ilike() operator is renamed from notilike() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.not_in">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>not_in(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.not_in">Â¶</a></dt>
<dd><p>implement the NOT IN operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a>, i.e. ~x.in_(y).</p>
<p>In the case that other is an empty sequence, the compiler produces an âempty not inâ expression. This defaults to the expression â1 = 1â to produce true in all cases. The <a href="engines.html#sqlalchemy.create_engine.params.empty_in_strategy">create_engine.empty_in_strategy</a> may be used to alter this behavior.</p>
<p>Changed in version 1.4: The not_in() operator is renamed from notin_() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>Changed in version 1.2: The <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a> and <a href="#sqlalchemy.sql.expression.ColumnOperators.not_in">ColumnOperators.not_in()</a> operators now produce a âstaticâ expression for an empty IN sequence by default.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.not_like">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>not_like(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.not_like">Â¶</a></dt>
<dd><p>implement the NOT LIKE operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a>, i.e. ~x.like(y).</p>
<p>Changed in version 1.4: The not_like() operator is renamed from notlike() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.notilike">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>notilike(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.notilike">Â¶</a></dt>
<dd><p>implement the NOT ILIKE operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a>, i.e. ~x.ilike(y).</p>
<p>Changed in version 1.4: The not_ilike() operator is renamed from notilike() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.ilike">ColumnOperators.ilike()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.notin_">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>notin_(other: Any) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.notin_">Â¶</a></dt>
<dd><p>implement the NOT IN operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a>, i.e. ~x.in_(y).</p>
<p>In the case that other is an empty sequence, the compiler produces an âempty not inâ expression. This defaults to the expression â1 = 1â to produce true in all cases. The <a href="engines.html#sqlalchemy.create_engine.params.empty_in_strategy">create_engine.empty_in_strategy</a> may be used to alter this behavior.</p>
<p>Changed in version 1.4: The not_in() operator is renamed from notin_() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>Changed in version 1.2: The <a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a> and <a href="#sqlalchemy.sql.expression.ColumnOperators.not_in">ColumnOperators.not_in()</a> operators now produce a âstaticâ expression for an empty IN sequence by default.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.in_">ColumnOperators.in_()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.notlike">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>notlike(other: Any, escape: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.notlike">Â¶</a></dt>
<dd><p>implement the NOT LIKE operator.</p>
<p>This is equivalent to using negation with <a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a>, i.e. ~x.like(y).</p>
<p>Changed in version 1.4: The not_like() operator is renamed from notlike() in previous releases. The previous name remains available for backwards compatibility.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.nulls_first">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>nulls_first() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_first">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> clause against the parent object.</p>
<p>Changed in version 1.4: The nulls_first() operator is renamed from nullsfirst() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.nulls_last">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>nulls_last() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.nulls_last">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a> clause against the parent object.</p>
<p>Changed in version 1.4: The nulls_last() operator is renamed from nullslast() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.nullsfirst">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>nullsfirst() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.nullsfirst">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> clause against the parent object.</p>
<p>Changed in version 1.4: The nulls_first() operator is renamed from nullsfirst() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.nullslast">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>nullslast() â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.nullslast">Â¶</a></dt>
<dd><p>Produce a <a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a> clause against the parent object.</p>
<p>Changed in version 1.4: The nulls_last() operator is renamed from nullslast() in previous releases.
The previous name remains available for backwards compatibility.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.op">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>op(opstring: str, precedence: int = 0, is_comparison: bool = False, return_type: Type[<a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>[Any]] | <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>[Any] | None = None, python_impl: Callable[..., Any] | None = None) â Callable[[Any], <a href="#sqlalchemy.sql.expression.Operators">Operators</a>]<a href="#sqlalchemy.sql.expression.ColumnOperators.op">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a> method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Produce a generic operator function.</p>
<p>e.g.:</p>
<pre>somecolumn.op("*")(5)</pre>
<p>produces:</p>
<pre>somecolumn * 5</pre>
<p>This function can also be used to make bitwise operators explicit. For example:</p>
<pre>somecolumn.op('&amp;')(0xff)</pre>
<p>is a bitwise AND of the value in somecolumn.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>opstring<a href="#sqlalchemy.sql.expression.ColumnOperators.op.params.opstring">Â¶</a> â a string which will be output as the infix operator between this element and the expression passed to the generated function.</p></li>
<li><p>precedence<a href="#sqlalchemy.sql.expression.ColumnOperators.op.params.precedence">Â¶</a> â <p>precedence which the database is expected to apply to the operator in SQL expressions. This integer value acts as a hint for the SQL compiler to know when explicit parenthesis should be rendered around a particular operation. A lower number will cause the expression to be parenthesized when applied against another operator with higher precedence. The default value of 0 is lower than all operators except for the comma (,) and AS operators. A value of 100 will be higher or equal to all operators, and -100 will be lower than or equal to all operators.</p>
<p>See also</p>
<p><a href="../faq/sqlexpressions.html#faq-sql-expression-op-parenthesis">Iâm using op() to generate a custom operator and my parenthesis are not coming out correctly</a> - detailed description of how the SQLAlchemy SQL compiler renders parenthesis</p>
</p></li>
<li><p>is_comparison<a href="#sqlalchemy.sql.expression.ColumnOperators.op.params.is_comparison">Â¶</a> â <p>legacy; if True, the operator will be considered as a âcomparisonâ operator, that is which evaluates to a boolean true/false value, like ==, &gt;, etc. This flag is provided so that ORM relationships can establish that the operator is a comparison operator when used in a custom join condition.</p>
<p>Using the is_comparison parameter is superseded by using the <a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a> method instead; this more succinct operator sets this parameter automatically, but also provides correct <a href="https://peps.python.org/pep-0484/">PEP 484</a> typing support as the returned object will express a âbooleanâ datatype, i.e. BinaryExpression[bool].</p>
</p></li>
<li><p>return_type<a href="#sqlalchemy.sql.expression.ColumnOperators.op.params.return_type">Â¶</a> â a <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> class or object that will force the return type of an expression produced by this operator to be of that type. By default, operators that specify <a href="#sqlalchemy.sql.expression.Operators.op.params.is_comparison">Operators.op.is_comparison</a> will resolve to <a href="type_basics.html#sqlalchemy.types.Boolean">Boolean</a>, and those that do not will be of the same type as the left-hand operand.</p></li>
<li><p>python_impl<a href="#sqlalchemy.sql.expression.ColumnOperators.op.params.python_impl">Â¶</a> â <p>an optional Python function that can evaluate two Python values in the same way as this operator works when run on the database server. Useful for in-Python SQL expression evaluation functions, such as for ORM hybrid attributes, and the ORM âevaluatorâ used to match objects in a session after a multi-row update or delete.</p>
<p>e.g.:</p>
<pre>&gt;&gt;&gt; expr = column('x').op('+', python_impl=lambda a, b: a + b)('y')</pre>
<p>The operator for the above expression will also work for non-SQL left and right objects:</p>
<pre>&gt;&gt;&gt; expr.operator(5, 10)
15</pre>
<p>New in version 2.0.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a></p>
<p><a href="custom_types.html#types-operators">Redefining and Creating New Operators</a></p>
<p><a href="../orm/join_conditions.html#relationship-custom-operator">Using custom operators in join conditions</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.operate">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>operate(op: OperatorType, *other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.operate">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.Operators.operate">Operators.operate()</a> method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Operate on an argument.</p>
<p>This is the lowest level of operation, raises NotImplementedError by default.</p>
<p>Overriding this on a subclass can allow common behavior to be applied to all operations.
For example, overriding <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a>
to apply func.lower() to the left and right side:</p>
<pre>class MyComparator(ColumnOperators):
def operate(self, op, other, **kwargs):
return op(func.lower(self), func.lower(other), **kwargs)</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>op<a href="#sqlalchemy.sql.expression.ColumnOperators.operate.params.op">Â¶</a> â Operator callable.</p></li>
<li><p>*other<a href="#sqlalchemy.sql.expression.ColumnOperators.operate.params.*other">Â¶</a> â the âotherâ side of the operation. Will be a single scalar for most operations.</p></li>
<li><p>**kwargs<a href="#sqlalchemy.sql.expression.ColumnOperators.operate.params.**kwargs">Â¶</a> â modifiers. These may be passed by special operators such as <a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.regexp_match">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>regexp_match(pattern: Any, flags: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match">Â¶</a></dt>
<dd><p>Implements a database-specific âregexp matchâ operator.</p>
<p>E.g.:</p>
<pre>stmt = select(table.c.some_column).where(
table.c.some_column.regexp_match('^(b|c)')
)</pre>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match">ColumnOperators.regexp_match()</a> attempts to resolve to a REGEXP-like function or operator provided by the backend, however the specific regular expression syntax and flags available are not backend agnostic.</p>
<p>Examples include:</p>
<ul>
<li><p>PostgreSQL - renders x ~ y or x !~ y when negated.</p></li>
<li><p>Oracle - renders REGEXP_LIKE(x, y)</p></li>
<li><p>SQLite - uses SQLiteâs REGEXP placeholder operator and calls into the Python re.match() builtin.</p></li>
<li><p>other backends may provide special implementations.</p></li>
<li><p>Backends without any special implementation will emit the operator as âREGEXPâ or âNOT REGEXPâ. This is compatible with SQLite and MySQL, for example.</p></li>
</ul>
<p>Regular expression support is currently implemented for Oracle, PostgreSQL, MySQL and MariaDB. Partial support is available for SQLite. Support among third-party dialects may vary.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>pattern<a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match.params.pattern">Â¶</a> â The regular expression pattern string or column clause.</p></li>
<li><p>flags<a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match.params.flags">Â¶</a> â Any regular expression string flags to apply, passed as plain Python string only. These flags are backend specific.
Some backends, like PostgreSQL and MariaDB, may alternatively specify the flags as part of the pattern.
When using the ignore case flag âiâ in PostgreSQL, the ignore case regexp match operator ~* or !~* will be used.</p></li>
</ul>
</dd>
</dl>
<p>New in version 1.4.</p>
<p>Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error, the âflagsâ parameter previously accepted SQL expression objects such as column expressions in addition to plain Python strings. This implementation did not work correctly with caching and was removed; strings only should be passed for the âflagsâ
parameter, as these flags are rendered as literal inline values within SQL expressions.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace">ColumnOperators.regexp_replace()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.regexp_replace">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>regexp_replace(pattern: Any, replacement: Any, flags: str | None = None) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace">Â¶</a></dt>
<dd><p>Implements a database-specific âregexp replaceâ operator.</p>
<p>E.g.:</p>
<pre>stmt = select(
table.c.some_column.regexp_replace(
'b(..)',
'XY',
flags='g'
)
)</pre>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace">ColumnOperators.regexp_replace()</a> attempts to resolve to a REGEXP_REPLACE-like function provided by the backend, that usually emit the function REGEXP_REPLACE(). However, the specific regular expression syntax and flags available are not backend agnostic.</p>
<p>Regular expression replacement support is currently implemented for Oracle, PostgreSQL, MySQL 8 or greater and MariaDB. Support among third-party dialects may vary.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>pattern<a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace.params.pattern">Â¶</a> â The regular expression pattern string or column clause.</p></li>
<li><p>pattern<a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace.params.pattern">Â¶</a> â The replacement string or column clause.</p></li>
<li><p>flags<a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_replace.params.flags">Â¶</a> â Any regular expression string flags to apply, passed as plain Python string only. These flags are backend specific.
Some backends, like PostgreSQL and MariaDB, may alternatively specify the flags as part of the pattern.</p></li>
</ul>
</dd>
</dl>
<p>New in version 1.4.</p>
<p>Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error, the âflagsâ parameter previously accepted SQL expression objects such as column expressions in addition to plain Python strings. This implementation did not work correctly with caching and was removed; strings only should be passed for the âflagsâ
parameter, as these flags are rendered as literal inline values within SQL expressions.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.regexp_match">ColumnOperators.regexp_match()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.reverse_operate">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>reverse_operate(op: OperatorType, other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.reverse_operate">Â¶</a></dt>
<dd>
<p>inherited from the <a href="#sqlalchemy.sql.expression.Operators.reverse_operate">Operators.reverse_operate()</a> method of <a href="#sqlalchemy.sql.expression.Operators">Operators</a></p>
<p>Reverse operate on an argument.</p>
<p>Usage is the same as <a href="#sqlalchemy.sql.expression.ColumnOperators.operate">operate()</a>.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.startswith">
method <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>startswith(other: Any, escape: str | None = None, autoescape: bool = False) â <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a><a href="#sqlalchemy.sql.expression.ColumnOperators.startswith">Â¶</a></dt>
<dd><p>Implement the startswith operator.</p>
<p>Produces a LIKE expression that tests against a match for the start of a string value:</p>
<pre>column LIKE &lt;other&gt; || '%'</pre>
<p>E.g.:</p>
<pre>stmt = select(sometable).\
where(sometable.c.column.startswith("foobar"))</pre>
<p>Since the operator uses LIKE, wildcard characters "%" and "_" that are present inside the &lt;other&gt; expression will behave like wildcards as well. For literal string values, the <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape">ColumnOperators.startswith.autoescape</a> flag may be set to True to apply escaping to occurrences of these characters within the string value so that they match as themselves and not as wildcard characters. Alternatively, the <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.escape">ColumnOperators.startswith.escape</a> parameter will establish a given character as an escape character which can be of use when the target expression is not a literal string.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>other<a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.other">Â¶</a> â expression to be compared. This is usually a plain string value, but can also be an arbitrary SQL expression. LIKE wildcard characters % and _ are not escaped by default unless the <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape">ColumnOperators.startswith.autoescape</a> flag is set to True.</p></li>
<li><p>autoescape<a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape">Â¶</a> â <p>boolean; when True, establishes an escape character within the LIKE expression, then applies it to all occurrences of "%", "_" and the escape character itself within the comparison value, which is assumed to be a literal string and not a SQL expression.</p>
<p>An expression such as:</p>
<pre>somecolumn.startswith("foo%bar", autoescape=True)</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE :param || '%' ESCAPE '/'</pre>
<p>With the value of :param as "foo/%bar".</p>
</p></li>
<li><p>escape<a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.escape">Â¶</a> â <p>a character which when given will render with the ESCAPE keyword to establish that character as the escape character. This character can then be placed preceding occurrences of % and _ to allow them to act as themselves and not wildcard characters.</p>
<p>An expression such as:</p>
<pre>somecolumn.startswith("foo/%bar", escape="^")</pre>
<p>Will render as:</p>
<pre>somecolumn LIKE :param || '%' ESCAPE '^'</pre>
<p>The parameter may also be combined with <a href="#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape">ColumnOperators.startswith.autoescape</a>:</p>
<pre>somecolumn.startswith("foo%bar^bat", escape="^", autoescape=True)</pre>
<p>Where above, the given literal parameter will be converted to "foo^%bar^^bat" before being passed to the database.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.endswith">ColumnOperators.endswith()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a></p>
<p><a href="#sqlalchemy.sql.expression.ColumnOperators.like">ColumnOperators.like()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.ColumnOperators.timetuple">
attribute <a href="#sqlalchemy.sql.expression.ColumnOperators">sqlalchemy.sql.expression.ColumnOperators.</a>timetuple: Literal[None] = None<a href="#sqlalchemy.sql.expression.ColumnOperators.timetuple">Â¶</a></dt>
<dd><p>Hack, allows datetime objects to be compared on the LHS.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Extract">
class sqlalchemy.sql.expression.Extract<a href="#sqlalchemy.sql.expression.Extract">Â¶</a></dt>
<dd><p>Represent a SQL EXTRACT clause, extract(field FROM expr).</p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.Extract">sqlalchemy.sql.expression.Extract</a> (<a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.False_">
class sqlalchemy.sql.expression.False_<a href="#sqlalchemy.sql.expression.False_">Â¶</a></dt>
<dd><p>Represent the false keyword, or equivalent, in a SQL statement.</p>
<p><a href="#sqlalchemy.sql.expression.False_">False_</a> is accessed as a constant via the <a href="#sqlalchemy.sql.expression.false">false()</a> function.</p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.False_">sqlalchemy.sql.expression.False_</a> (sqlalchemy.sql.expression.SingletonConstant, sqlalchemy.sql.roles.ConstExprRole, <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.FunctionFilter">
class sqlalchemy.sql.expression.FunctionFilter<a href="#sqlalchemy.sql.expression.FunctionFilter">Â¶</a></dt>
<dd><p>Represent a function FILTER clause.</p>
<p>This is a special operator against aggregate and window functions, which controls which rows are passed to it.
Itâs supported only by certain database backends.</p>
<p>Invocation of <a href="#sqlalchemy.sql.expression.FunctionFilter">FunctionFilter</a> is via <a href="functions.html#sqlalchemy.sql.functions.FunctionElement.filter">FunctionElement.filter()</a>:</p>
<pre>func.count(1).filter(True)</pre>
<p>See also</p>
<p><a href="functions.html#sqlalchemy.sql.functions.FunctionElement.filter">FunctionElement.filter()</a></p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.FunctionFilter.filter">filter()</a>, <a href="#sqlalchemy.sql.expression.FunctionFilter.over">over()</a>, <a href="#sqlalchemy.sql.expression.FunctionFilter.self_group">self_group()</a>, <a href="#sqlalchemy.sql.expression.FunctionFilter.within_group">within_group()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.FunctionFilter">sqlalchemy.sql.expression.FunctionFilter</a> (sqlalchemy.sql.expression.Generative, <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
<dl>
<dt id="sqlalchemy.sql.expression.FunctionFilter.filter">
method <a href="#sqlalchemy.sql.expression.FunctionFilter">sqlalchemy.sql.expression.FunctionFilter.</a>filter(*criterion: _ColumnExpressionArgument[bool]) â Self<a href="#sqlalchemy.sql.expression.FunctionFilter.filter">Â¶</a></dt>
<dd><p>Produce an additional FILTER against the function.</p>
<p>This method adds additional criteria to the initial criteria set up by <a href="functions.html#sqlalchemy.sql.functions.FunctionElement.filter">FunctionElement.filter()</a>.</p>
<p>Multiple criteria are joined together at SQL render time via AND.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.FunctionFilter.over">
method <a href="#sqlalchemy.sql.expression.FunctionFilter">sqlalchemy.sql.expression.FunctionFilter.</a>over(partition_by: Iterable[_ColumnExpressionArgument[Any]] | _ColumnExpressionArgument[Any] | None = None, order_by: Iterable[_ColumnExpressionArgument[Any]] | _ColumnExpressionArgument[Any] | None = None, range_: typing_Tuple[int | None, int | None] | None = None, rows: typing_Tuple[int | None, int | None] | None = None) â <a href="#sqlalchemy.sql.expression.Over">Over</a>[_T]<a href="#sqlalchemy.sql.expression.FunctionFilter.over">Â¶</a></dt>
<dd><p>Produce an OVER clause against this filtered function.</p>
<p>Used against aggregate or so-called âwindowâ functions, for database backends that support window functions.</p>
<p>The expression:</p>
<pre>func.rank().filter(MyClass.y &gt; 5).over(order_by='x')</pre>
<p>is shorthand for:</p>
<pre>from sqlalchemy import over, funcfilter
over(funcfilter(func.rank(), MyClass.y &gt; 5), order_by='x')</pre>
<p>See <a href="#sqlalchemy.sql.expression.over">over()</a> for a full description.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.FunctionFilter.self_group">
method <a href="#sqlalchemy.sql.expression.FunctionFilter">sqlalchemy.sql.expression.FunctionFilter.</a>self_group(against: OperatorType | None = None) â Self | Grouping[_T]<a href="#sqlalchemy.sql.expression.FunctionFilter.self_group">Â¶</a></dt>
<dd><p>Apply a âgroupingâ to this <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>.</p>
<p>This method is overridden by subclasses to return a âgroupingâ
construct, i.e. parenthesis. In particular itâs used by âbinaryâ
expressions to provide a grouping around themselves when placed into a larger expression, as well as by <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
constructs when placed into the FROM clause of another <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>. (Note that subqueries should be normally created using the <a href="selectable.html#sqlalchemy.sql.expression.Select.alias">Select.alias()</a> method, as many platforms require nested SELECT statements to be named).</p>
<p>As expressions are composed together, the application of <a href="#sqlalchemy.sql.expression.FunctionFilter.self_group">self_group()</a> is automatic - end-user code should never need to use this method directly. Note that SQLAlchemyâs clause constructs take operator precedence into account -
so parenthesis might not be needed, for example, in an expression like x OR (y AND z) - AND takes precedence over OR.</p>
<p>The base <a href="#sqlalchemy.sql.expression.FunctionFilter.self_group">self_group()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>
just returns self.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.FunctionFilter.within_group">
method <a href="#sqlalchemy.sql.expression.FunctionFilter">sqlalchemy.sql.expression.FunctionFilter.</a>within_group(*order_by: _ColumnExpressionArgument[Any]) â <a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a>[_T]<a href="#sqlalchemy.sql.expression.FunctionFilter.within_group">Â¶</a></dt>
<dd><p>Produce a WITHIN GROUP (ORDER BY expr) clause against this function.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Label">
class sqlalchemy.sql.expression.Label<a href="#sqlalchemy.sql.expression.Label">Â¶</a></dt>
<dd><p>Represents a column label (AS).</p>
<p>Represent a label, as typically applied to any column-level element using the AS sql keyword.</p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.Label.foreign_keys">foreign_keys</a>, <a href="#sqlalchemy.sql.expression.Label.primary_key">primary_key</a>, <a href="#sqlalchemy.sql.expression.Label.self_group">self_group()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.Label">sqlalchemy.sql.expression.Label</a> (sqlalchemy.sql.roles.LabeledColumnExprRole, sqlalchemy.sql.expression.NamedColumn)</p>
<dl>
<dt id="sqlalchemy.sql.expression.Label.foreign_keys">
attribute <a href="#sqlalchemy.sql.expression.Label">sqlalchemy.sql.expression.Label.</a>foreign_keys: AbstractSet[<a href="constraints.html#sqlalchemy.schema.ForeignKey">ForeignKey</a>]<a href="#sqlalchemy.sql.expression.Label.foreign_keys">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Label.primary_key">
attribute <a href="#sqlalchemy.sql.expression.Label">sqlalchemy.sql.expression.Label.</a>primary_key: bool<a href="#sqlalchemy.sql.expression.Label.primary_key">Â¶</a></dt>
<dd></dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Label.self_group">
method <a href="#sqlalchemy.sql.expression.Label">sqlalchemy.sql.expression.Label.</a>self_group(against: OperatorType | None = None) â <a href="#sqlalchemy.sql.expression.Label">Label</a>[_T]<a href="#sqlalchemy.sql.expression.Label.self_group">Â¶</a></dt>
<dd><p>Apply a âgroupingâ to this <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>.</p>
<p>This method is overridden by subclasses to return a âgroupingâ
construct, i.e. parenthesis. In particular itâs used by âbinaryâ
expressions to provide a grouping around themselves when placed into a larger expression, as well as by <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
constructs when placed into the FROM clause of another <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>. (Note that subqueries should be normally created using the <a href="selectable.html#sqlalchemy.sql.expression.Select.alias">Select.alias()</a> method, as many platforms require nested SELECT statements to be named).</p>
<p>As expressions are composed together, the application of <a href="#sqlalchemy.sql.expression.Label.self_group">self_group()</a> is automatic - end-user code should never need to use this method directly. Note that SQLAlchemyâs clause constructs take operator precedence into account -
so parenthesis might not be needed, for example, in an expression like x OR (y AND z) - AND takes precedence over OR.</p>
<p>The base <a href="#sqlalchemy.sql.expression.Label.self_group">self_group()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>
just returns self.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Null">
class sqlalchemy.sql.expression.Null<a href="#sqlalchemy.sql.expression.Null">Â¶</a></dt>
<dd><p>Represent the NULL keyword in a SQL statement.</p>
<p><a href="#sqlalchemy.sql.expression.Null">Null</a> is accessed as a constant via the <a href="#sqlalchemy.sql.expression.null">null()</a> function.</p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.Null">sqlalchemy.sql.expression.Null</a> (sqlalchemy.sql.expression.SingletonConstant, sqlalchemy.sql.roles.ConstExprRole, <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Operators">
class sqlalchemy.sql.expression.Operators<a href="#sqlalchemy.sql.expression.Operators">Â¶</a></dt>
<dd><p>Base of comparison and logical operators.</p>
<p>Implements base methods Operators.operate() and Operators.reverse_operate(), as well as Operators.__and__(), Operators.__or__(), Operators.__invert__().</p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.Operators.__and__">__and__()</a>, <a href="#sqlalchemy.sql.expression.Operators.__invert__">__invert__()</a>, <a href="#sqlalchemy.sql.expression.Operators.__or__">__or__()</a>, <a href="#sqlalchemy.sql.expression.Operators.__sa_operate__">__sa_operate__()</a>, <a href="#sqlalchemy.sql.expression.Operators.bool_op">bool_op()</a>, <a href="#sqlalchemy.sql.expression.Operators.op">op()</a>, <a href="#sqlalchemy.sql.expression.Operators.operate">operate()</a>, <a href="#sqlalchemy.sql.expression.Operators.reverse_operate">reverse_operate()</a></p>
<p>Usually is used via its most common subclass <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a>.</p>
<dl>
<dt id="sqlalchemy.sql.expression.Operators.__and__">
method <a href="#sqlalchemy.sql.expression.Operators">sqlalchemy.sql.expression.Operators.</a>__and__(other: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.Operators.__and__">Â¶</a></dt>
<dd><p>Implement the &amp; operator.</p>
<p>When used with SQL expressions, results in an AND operation, equivalent to <a href="#sqlalchemy.sql.expression.and_">and_()</a>, that is:</p>
<pre>a &amp; b</pre>
<p>is equivalent to:</p>
<pre>from sqlalchemy import and_
and_(a, b)</pre>
<p>Care should be taken when using &amp; regarding operator precedence; the &amp; operator has the highest precedence.
The operands should be enclosed in parenthesis if they contain further sub expressions:</p>
<pre>(a == 2) &amp; (b == 4)</pre>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Operators.__invert__">
method <a href="#sqlalchemy.sql.expression.Operators">sqlalchemy.sql.expression.Operators.</a>__invert__() â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.Operators.__invert__">Â¶</a></dt>
<dd><p>Implement the ~ operator.</p>
<p>When used with SQL expressions, results in a NOT operation, equivalent to <a href="#sqlalchemy.sql.expression.not_">not_()</a>, that is:</p>
<pre>~a</pre>
<p>is equivalent to:</p>
<pre>from sqlalchemy import not_
not_(a)</pre>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Operators.__or__">
method <a href="#sqlalchemy.sql.expression.Operators">sqlalchemy.sql.expression.Operators.</a>__or__(other: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.Operators.__or__">Â¶</a></dt>
<dd><p>Implement the | operator.</p>
<p>When used with SQL expressions, results in an OR operation, equivalent to <a href="#sqlalchemy.sql.expression.or_">or_()</a>, that is:</p>
<pre>a | b</pre>
<p>is equivalent to:</p>
<pre>from sqlalchemy import or_
or_(a, b)</pre>
<p>Care should be taken when using | regarding operator precedence; the | operator has the highest precedence.
The operands should be enclosed in parenthesis if they contain further sub expressions:</p>
<pre>(a == 2) | (b == 4)</pre>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Operators.__sa_operate__">
method <a href="#sqlalchemy.sql.expression.Operators">sqlalchemy.sql.expression.Operators.</a>__sa_operate__(op: OperatorType, *other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.Operators.__sa_operate__">Â¶</a></dt>
<dd><p>Operate on an argument.</p>
<p>This is the lowest level of operation, raises NotImplementedError by default.</p>
<p>Overriding this on a subclass can allow common behavior to be applied to all operations.
For example, overriding <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a>
to apply func.lower() to the left and right side:</p>
<pre>class MyComparator(ColumnOperators):
def operate(self, op, other, **kwargs):
return op(func.lower(self), func.lower(other), **kwargs)</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>op<a href="#sqlalchemy.sql.expression.Operators.__sa_operate__.params.op">Â¶</a> â Operator callable.</p></li>
<li><p>*other<a href="#sqlalchemy.sql.expression.Operators.__sa_operate__.params.*other">Â¶</a> â the âotherâ side of the operation. Will be a single scalar for most operations.</p></li>
<li><p>**kwargs<a href="#sqlalchemy.sql.expression.Operators.__sa_operate__.params.**kwargs">Â¶</a> â modifiers. These may be passed by special operators such as <a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Operators.bool_op">
method <a href="#sqlalchemy.sql.expression.Operators">sqlalchemy.sql.expression.Operators.</a>bool_op(opstring: str, precedence: int = 0, python_impl: Callable[[...], Any] | None = None) â Callable[[Any], <a href="#sqlalchemy.sql.expression.Operators">Operators</a>]<a href="#sqlalchemy.sql.expression.Operators.bool_op">Â¶</a></dt>
<dd><p>Return a custom boolean operator.</p>
<p>This method is shorthand for calling <a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a> and passing the <a href="#sqlalchemy.sql.expression.Operators.op.params.is_comparison">Operators.op.is_comparison</a>
flag with True. A key advantage to using <a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a>
is that when using column constructs, the âbooleanâ nature of the returned expression will be present for <a href="https://peps.python.org/pep-0484/">PEP 484</a> purposes.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.Operators.op">Operators.op()</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Operators.op">
method <a href="#sqlalchemy.sql.expression.Operators">sqlalchemy.sql.expression.Operators.</a>op(opstring: str, precedence: int = 0, is_comparison: bool = False, return_type: Type[<a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>[Any]] | <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>[Any] | None = None, python_impl: Callable[..., Any] | None = None) â Callable[[Any], <a href="#sqlalchemy.sql.expression.Operators">Operators</a>]<a href="#sqlalchemy.sql.expression.Operators.op">Â¶</a></dt>
<dd><p>Produce a generic operator function.</p>
<p>e.g.:</p>
<pre>somecolumn.op("*")(5)</pre>
<p>produces:</p>
<pre>somecolumn * 5</pre>
<p>This function can also be used to make bitwise operators explicit. For example:</p>
<pre>somecolumn.op('&amp;')(0xff)</pre>
<p>is a bitwise AND of the value in somecolumn.</p>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>opstring<a href="#sqlalchemy.sql.expression.Operators.op.params.opstring">Â¶</a> â a string which will be output as the infix operator between this element and the expression passed to the generated function.</p></li>
<li><p>precedence<a href="#sqlalchemy.sql.expression.Operators.op.params.precedence">Â¶</a> â <p>precedence which the database is expected to apply to the operator in SQL expressions. This integer value acts as a hint for the SQL compiler to know when explicit parenthesis should be rendered around a particular operation. A lower number will cause the expression to be parenthesized when applied against another operator with higher precedence. The default value of 0 is lower than all operators except for the comma (,) and AS operators. A value of 100 will be higher or equal to all operators, and -100 will be lower than or equal to all operators.</p>
<p>See also</p>
<p><a href="../faq/sqlexpressions.html#faq-sql-expression-op-parenthesis">Iâm using op() to generate a custom operator and my parenthesis are not coming out correctly</a> - detailed description of how the SQLAlchemy SQL compiler renders parenthesis</p>
</p></li>
<li><p>is_comparison<a href="#sqlalchemy.sql.expression.Operators.op.params.is_comparison">Â¶</a> â <p>legacy; if True, the operator will be considered as a âcomparisonâ operator, that is which evaluates to a boolean true/false value, like ==, &gt;, etc. This flag is provided so that ORM relationships can establish that the operator is a comparison operator when used in a custom join condition.</p>
<p>Using the is_comparison parameter is superseded by using the <a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a> method instead; this more succinct operator sets this parameter automatically, but also provides correct <a href="https://peps.python.org/pep-0484/">PEP 484</a> typing support as the returned object will express a âbooleanâ datatype, i.e. BinaryExpression[bool].</p>
</p></li>
<li><p>return_type<a href="#sqlalchemy.sql.expression.Operators.op.params.return_type">Â¶</a> â a <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> class or object that will force the return type of an expression produced by this operator to be of that type. By default, operators that specify <a href="#sqlalchemy.sql.expression.Operators.op.params.is_comparison">Operators.op.is_comparison</a> will resolve to <a href="type_basics.html#sqlalchemy.types.Boolean">Boolean</a>, and those that do not will be of the same type as the left-hand operand.</p></li>
<li><p>python_impl<a href="#sqlalchemy.sql.expression.Operators.op.params.python_impl">Â¶</a> â <p>an optional Python function that can evaluate two Python values in the same way as this operator works when run on the database server. Useful for in-Python SQL expression evaluation functions, such as for ORM hybrid attributes, and the ORM âevaluatorâ used to match objects in a session after a multi-row update or delete.</p>
<p>e.g.:</p>
<pre>&gt;&gt;&gt; expr = column('x').op('+', python_impl=lambda a, b: a + b)('y')</pre>
<p>The operator for the above expression will also work for non-SQL left and right objects:</p>
<pre>&gt;&gt;&gt; expr.operator(5, 10)
15</pre>
<p>New in version 2.0.</p>
</p></li>
</ul>
</dd>
</dl>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.Operators.bool_op">Operators.bool_op()</a></p>
<p><a href="custom_types.html#types-operators">Redefining and Creating New Operators</a></p>
<p><a href="../orm/join_conditions.html#relationship-custom-operator">Using custom operators in join conditions</a></p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Operators.operate">
method <a href="#sqlalchemy.sql.expression.Operators">sqlalchemy.sql.expression.Operators.</a>operate(op: OperatorType, *other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.Operators.operate">Â¶</a></dt>
<dd><p>Operate on an argument.</p>
<p>This is the lowest level of operation, raises NotImplementedError by default.</p>
<p>Overriding this on a subclass can allow common behavior to be applied to all operations.
For example, overriding <a href="#sqlalchemy.sql.expression.ColumnOperators">ColumnOperators</a>
to apply func.lower() to the left and right side:</p>
<pre>class MyComparator(ColumnOperators):
def operate(self, op, other, **kwargs):
return op(func.lower(self), func.lower(other), **kwargs)</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>op<a href="#sqlalchemy.sql.expression.Operators.operate.params.op">Â¶</a> â Operator callable.</p></li>
<li><p>*other<a href="#sqlalchemy.sql.expression.Operators.operate.params.*other">Â¶</a> â the âotherâ side of the operation. Will be a single scalar for most operations.</p></li>
<li><p>**kwargs<a href="#sqlalchemy.sql.expression.Operators.operate.params.**kwargs">Â¶</a> â modifiers. These may be passed by special operators such as <a href="#sqlalchemy.sql.expression.ColumnOperators.contains">ColumnOperators.contains()</a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Operators.reverse_operate">
method <a href="#sqlalchemy.sql.expression.Operators">sqlalchemy.sql.expression.Operators.</a>reverse_operate(op: OperatorType, other: Any, **kwargs: Any) â <a href="#sqlalchemy.sql.expression.Operators">Operators</a><a href="#sqlalchemy.sql.expression.Operators.reverse_operate">Â¶</a></dt>
<dd><p>Reverse operate on an argument.</p>
<p>Usage is the same as <a href="#sqlalchemy.sql.expression.Operators.operate">operate()</a>.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Over">
class sqlalchemy.sql.expression.Over<a href="#sqlalchemy.sql.expression.Over">Â¶</a></dt>
<dd><p>Represent an OVER clause.</p>
<p>This is a special operator against a so-called âwindowâ function, as well as any aggregate function, which produces results relative to the result set itself. Most modern SQL backends now support window functions.</p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.Over.element">element</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.Over">sqlalchemy.sql.expression.Over</a> (<a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
<dl>
<dt id="sqlalchemy.sql.expression.Over.element">
attribute <a href="#sqlalchemy.sql.expression.Over">sqlalchemy.sql.expression.Over.</a>element: <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>[_T]<a href="#sqlalchemy.sql.expression.Over.element">Â¶</a></dt>
<dd><p>The underlying expression object to which this <a href="#sqlalchemy.sql.expression.Over">Over</a>
object refers.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.SQLColumnExpression">
class sqlalchemy.sql.expression.SQLColumnExpression<a href="#sqlalchemy.sql.expression.SQLColumnExpression">Â¶</a></dt>
<dd><p>A type that may be used to indicate any SQL column element or object that acts in place of one.</p>
<p><a href="#sqlalchemy.sql.expression.SQLColumnExpression">SQLColumnExpression</a> is a base of <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>, as well as within the bases of ORM elements such as <a href="../orm/internals.html#sqlalchemy.orm.InstrumentedAttribute">InstrumentedAttribute</a>, and may be used in <a href="https://peps.python.org/pep-0484/">PEP 484</a>
typing to indicate arguments or return values that should behave as column expressions.</p>
<p>New in version 2.0.0b4.</p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.SQLColumnExpression">sqlalchemy.sql.expression.SQLColumnExpression</a> (sqlalchemy.sql.expression.SQLCoreOperations, sqlalchemy.sql.roles.ExpressionElementRole, sqlalchemy.util.langhelpers.TypingOnly)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.TextClause">
class sqlalchemy.sql.expression.TextClause<a href="#sqlalchemy.sql.expression.TextClause">Â¶</a></dt>
<dd><p>Represent a literal SQL text fragment.</p>
<p>E.g.:</p>
<pre>from sqlalchemy import text
t = text("SELECT * FROM users")
result = connection.execute(t)</pre>
<p>The <a href="#sqlalchemy.sql.expression.TextClause">TextClause</a> construct is produced using the <a href="#sqlalchemy.sql.expression.text">text()</a>
function; see that function for full documentation.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.text">text()</a></p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.TextClause.bindparams">bindparams()</a>, <a href="#sqlalchemy.sql.expression.TextClause.columns">columns()</a>, <a href="#sqlalchemy.sql.expression.TextClause.self_group">self_group()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.TextClause">sqlalchemy.sql.expression.TextClause</a> (sqlalchemy.sql.roles.DDLConstraintColumnRole, sqlalchemy.sql.roles.DDLExpressionRole, sqlalchemy.sql.roles.StatementOptionRole, sqlalchemy.sql.roles.WhereHavingRole, sqlalchemy.sql.roles.OrderByRole, sqlalchemy.sql.roles.FromClauseRole, sqlalchemy.sql.roles.SelectStatementRole, sqlalchemy.sql.roles.InElementRole, sqlalchemy.sql.expression.Generative, <a href="selectable.html#sqlalchemy.sql.expression.Executable">sqlalchemy.sql.expression.Executable</a>, sqlalchemy.sql.expression.DQLDMLClauseElement, sqlalchemy.sql.roles.BinaryElementRole, sqlalchemy.inspection.Inspectable)</p>
<dl>
<dt id="sqlalchemy.sql.expression.TextClause.bindparams">
method <a href="#sqlalchemy.sql.expression.TextClause">sqlalchemy.sql.expression.TextClause.</a>bindparams(*binds: <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a>[Any], **names_to_values: Any) â Self<a href="#sqlalchemy.sql.expression.TextClause.bindparams">Â¶</a></dt>
<dd><p>Establish the values and/or types of bound parameters within this <a href="#sqlalchemy.sql.expression.TextClause">TextClause</a> construct.</p>
<p>Given a text construct such as:</p>
<pre>from sqlalchemy import text
stmt = text("SELECT id, name FROM user WHERE name=:name "
"AND timestamp=:timestamp")</pre>
<p>the <a href="#sqlalchemy.sql.expression.TextClause.bindparams">TextClause.bindparams()</a>
method can be used to establish the initial value of :name and :timestamp, using simple keyword arguments:</p>
<pre>stmt = stmt.bindparams(name='jack',
timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5))</pre>
<p>Where above, new <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> objects will be generated with the names name and timestamp, and values of jack and datetime.datetime(2012, 10, 8, 15, 12, 5), respectively. The types will be inferred from the values given, in this case <a href="type_basics.html#sqlalchemy.types.String">String</a> and <a href="type_basics.html#sqlalchemy.types.DateTime">DateTime</a>.</p>
<p>When specific typing behavior is needed, the positional *binds argument can be used in which to specify <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a> constructs directly. These constructs must include at least the key argument, then an optional value and type:</p>
<pre>from sqlalchemy import bindparam
stmt = stmt.bindparams(
bindparam('name', value='jack', type_=String),
bindparam('timestamp', type_=DateTime)
)</pre>
<p>Above, we specified the type of <a href="type_basics.html#sqlalchemy.types.DateTime">DateTime</a> for the timestamp bind, and the type of <a href="type_basics.html#sqlalchemy.types.String">String</a> for the name bind. In the case of name we also set the default value of "jack".</p>
<p>Additional bound parameters can be supplied at statement execution time, e.g.:</p>
<pre>result = connection.execute(stmt,
timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5))</pre>
<p>The <a href="#sqlalchemy.sql.expression.TextClause.bindparams">TextClause.bindparams()</a>
method can be called repeatedly, where it will re-use existing <a href="#sqlalchemy.sql.expression.BindParameter">BindParameter</a> objects to add new information. For example, we can call <a href="#sqlalchemy.sql.expression.TextClause.bindparams">TextClause.bindparams()</a>
first with typing information, and a second time with value information, and it will be combined:</p>
<pre>stmt = text("SELECT id, name FROM user WHERE name=:name "
"AND timestamp=:timestamp")
stmt = stmt.bindparams(
bindparam('name', type_=String),
bindparam('timestamp', type_=DateTime)
)
stmt = stmt.bindparams(
name='jack',
timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5)
)</pre>
<p>The <a href="#sqlalchemy.sql.expression.TextClause.bindparams">TextClause.bindparams()</a>
method also supports the concept of unique bound parameters. These are parameters that are âuniquifiedâ on name at statement compilation time, so that multiple <a href="#sqlalchemy.sql.expression.text">text()</a>
constructs may be combined together without the names conflicting. To use this feature, specify the <a href="#sqlalchemy.sql.expression.BindParameter.params.unique">BindParameter.unique</a> flag on each <a href="#sqlalchemy.sql.expression.bindparam">bindparam()</a>
object:</p>
<pre>stmt1 = text("select id from table where name=:name").bindparams(
bindparam("name", value='name1', unique=True)
)
stmt2 = text("select id from table where name=:name").bindparams(
bindparam("name", value='name2', unique=True)
)
union = union_all(
stmt1.columns(column("id")),
stmt2.columns(column("id"))
)</pre>
<p>The above statement will render as:</p>
<pre>select id from table where name=:name_1
UNION ALL select id from table where name=:name_2</pre>
<p>New in version 1.3.11: Added support for the <a href="#sqlalchemy.sql.expression.BindParameter.params.unique">BindParameter.unique</a> flag to work with <a href="#sqlalchemy.sql.expression.text">text()</a>
constructs.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.TextClause.columns">
method <a href="#sqlalchemy.sql.expression.TextClause">sqlalchemy.sql.expression.TextClause.</a>columns(*cols: _ColumnExpressionArgument[Any], **types: <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>[Any]) â <a href="selectable.html#sqlalchemy.sql.expression.TextualSelect">TextualSelect</a><a href="#sqlalchemy.sql.expression.TextClause.columns">Â¶</a></dt>
<dd><p>Turn this <a href="#sqlalchemy.sql.expression.TextClause">TextClause</a> object into a <a href="selectable.html#sqlalchemy.sql.expression.TextualSelect">TextualSelect</a>
object that serves the same role as a SELECT statement.</p>
<p>The <a href="selectable.html#sqlalchemy.sql.expression.TextualSelect">TextualSelect</a> is part of the <a href="selectable.html#sqlalchemy.sql.expression.SelectBase">SelectBase</a>
hierarchy and can be embedded into another statement by using the <a href="selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery">TextualSelect.subquery()</a> method to produce a <a href="selectable.html#sqlalchemy.sql.expression.Subquery">Subquery</a>
object, which can then be SELECTed from.</p>
<p>This function essentially bridges the gap between an entirely textual SELECT statement and the SQL expression language concept of a âselectableâ:</p>
<pre>from sqlalchemy.sql import column, text
stmt = text("SELECT id, name FROM some_table")
stmt = stmt.columns(column('id'), column('name')).subquery('st')
stmt = select(mytable).\
select_from(
mytable.join(stmt, mytable.c.name == stmt.c.name)
).where(stmt.c.id &gt; 5)</pre>
<p>Above, we pass a series of <a href="#sqlalchemy.sql.expression.column">column()</a> elements to the <a href="#sqlalchemy.sql.expression.TextClause.columns">TextClause.columns()</a> method positionally. These <a href="#sqlalchemy.sql.expression.column">column()</a>
elements now become first class elements upon the <a href="selectable.html#sqlalchemy.sql.expression.TextualSelect.selected_columns">TextualSelect.selected_columns</a> column collection, which then become part of the Subquery.c collection after <a href="selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery">TextualSelect.subquery()</a> is invoked.</p>
<p>The column expressions we pass to <a href="#sqlalchemy.sql.expression.TextClause.columns">TextClause.columns()</a> may also be typed; when we do so, these <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a> objects become the effective return type of the column, so that SQLAlchemyâs result-set-processing systems may be used on the return values.
This is often needed for types such as date or boolean types, as well as for unicode processing on some dialect configurations:</p>
<pre>stmt = text("SELECT id, name, timestamp FROM some_table")
stmt = stmt.columns(
column('id', Integer),
column('name', Unicode),
column('timestamp', DateTime)
)
for id, name, timestamp in connection.execute(stmt):
print(id, name, timestamp)</pre>
<p>As a shortcut to the above syntax, keyword arguments referring to types alone may be used, if only type conversion is needed:</p>
<pre>stmt = text("SELECT id, name, timestamp FROM some_table")
stmt = stmt.columns(
id=Integer,
name=Unicode,
timestamp=DateTime
)
for id, name, timestamp in connection.execute(stmt):
print(id, name, timestamp)</pre>
<p>The positional form of <a href="#sqlalchemy.sql.expression.TextClause.columns">TextClause.columns()</a>
also provides the unique feature of positional column targeting, which is particularly useful when using the ORM with complex textual queries. If we specify the columns from our model to <a href="#sqlalchemy.sql.expression.TextClause.columns">TextClause.columns()</a>, the result set will match to those columns positionally, meaning the name or origin of the column in the textual SQL doesnât matter:</p>
<pre>stmt = text("SELECT users.id, addresses.id, users.id, "
"users.name, addresses.email_address AS email "
"FROM users JOIN addresses ON users.id=addresses.user_id "
"WHERE users.id = 1").columns(
User.id,
Address.id,
Address.user_id,
User.name,
Address.email_address
)
query = session.query(User).from_statement(stmt).options(
contains_eager(User.addresses))</pre>
<p>The <a href="#sqlalchemy.sql.expression.TextClause.columns">TextClause.columns()</a> method provides a direct route to calling FromClause.subquery() as well as <a href="selectable.html#sqlalchemy.sql.expression.SelectBase.cte">SelectBase.cte()</a>
against a textual SELECT statement:</p>
<pre>stmt = stmt.columns(id=Integer, name=String).cte('st')
stmt = select(sometable).where(sometable.c.id == stmt.c.id)</pre>
<dl>
<dt>Parameters:</dt>
<dd><ul>
<li><p>*cols<a href="#sqlalchemy.sql.expression.TextClause.columns.params.*cols">Â¶</a> â A series of <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a> objects, typically <a href="metadata.html#sqlalchemy.schema.Column">Column</a> objects from a <a href="metadata.html#sqlalchemy.schema.Table">Table</a>
or ORM level column-mapped attributes, representing a set of columns that this textual string will SELECT from.</p></li>
<li><p>**types<a href="#sqlalchemy.sql.expression.TextClause.columns.params.**types">Â¶</a> â A mapping of string names to <a href="type_api.html#sqlalchemy.types.TypeEngine">TypeEngine</a>
type objects indicating the datatypes to use for names that are SELECTed from the textual string. Prefer to use the *cols argument as it also indicates positional ordering.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.TextClause.self_group">
method <a href="#sqlalchemy.sql.expression.TextClause">sqlalchemy.sql.expression.TextClause.</a>self_group(against: OperatorType | None = None) â Self | Grouping[Any]<a href="#sqlalchemy.sql.expression.TextClause.self_group">Â¶</a></dt>
<dd><p>Apply a âgroupingâ to this <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>.</p>
<p>This method is overridden by subclasses to return a âgroupingâ
construct, i.e. parenthesis. In particular itâs used by âbinaryâ
expressions to provide a grouping around themselves when placed into a larger expression, as well as by <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
constructs when placed into the FROM clause of another <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>. (Note that subqueries should be normally created using the <a href="selectable.html#sqlalchemy.sql.expression.Select.alias">Select.alias()</a> method, as many platforms require nested SELECT statements to be named).</p>
<p>As expressions are composed together, the application of <a href="#sqlalchemy.sql.expression.TextClause.self_group">self_group()</a> is automatic - end-user code should never need to use this method directly. Note that SQLAlchemyâs clause constructs take operator precedence into account -
so parenthesis might not be needed, for example, in an expression like x OR (y AND z) - AND takes precedence over OR.</p>
<p>The base <a href="#sqlalchemy.sql.expression.TextClause.self_group">self_group()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>
just returns self.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.TryCast">
class sqlalchemy.sql.expression.TryCast<a href="#sqlalchemy.sql.expression.TryCast">Â¶</a></dt>
<dd><p>Represent a TRY_CAST expression.</p>
<p>Details on <a href="#sqlalchemy.sql.expression.TryCast">TryCast</a> usage is at <a href="#sqlalchemy.sql.expression.try_cast">try_cast()</a>.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.try_cast">try_cast()</a></p>
<p><a href="../tutorial/data_select.html#tutorial-casts">Data Casts and Type Coercion</a></p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.TryCast.inherit_cache">inherit_cache</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.TryCast">sqlalchemy.sql.expression.TryCast</a> (<a href="#sqlalchemy.sql.expression.Cast">sqlalchemy.sql.expression.Cast</a>)</p>
<dl>
<dt id="sqlalchemy.sql.expression.TryCast.inherit_cache">
attribute <a href="#sqlalchemy.sql.expression.TryCast">sqlalchemy.sql.expression.TryCast.</a>inherit_cache: bool | None = True<a href="#sqlalchemy.sql.expression.TryCast.inherit_cache">Â¶</a></dt>
<dd><p>Indicate if this <a href="foundation.html#sqlalchemy.sql.traversals.HasCacheKey">HasCacheKey</a> instance should make use of the cache key generation scheme used by its immediate superclass.</p>
<p>The attribute defaults to None, which indicates that a construct has not yet taken into account whether or not its appropriate for it to participate in caching; this is functionally equivalent to setting the value to False, except that a warning is also emitted.</p>
<p>This flag can be set to True on a particular class, if the SQL that corresponds to the object does not change based on attributes which are local to this class, and not its superclass.</p>
<p>See also</p>
<p><a href="compiler.html#compilerext-caching">Enabling Caching Support for Custom Constructs</a> - General guideslines for setting the <a href="foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache">HasCacheKey.inherit_cache</a> attribute for third-party or user defined SQL constructs.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.Tuple">
class sqlalchemy.sql.expression.Tuple<a href="#sqlalchemy.sql.expression.Tuple">Â¶</a></dt>
<dd><p>Represent a SQL tuple.</p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.Tuple.self_group">self_group()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.Tuple">sqlalchemy.sql.expression.Tuple</a> (<a href="#sqlalchemy.sql.expression.ClauseList">sqlalchemy.sql.expression.ClauseList</a>, <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
<dl>
<dt id="sqlalchemy.sql.expression.Tuple.self_group">
method <a href="#sqlalchemy.sql.expression.Tuple">sqlalchemy.sql.expression.Tuple.</a>self_group(against: OperatorType | None = None) â Self<a href="#sqlalchemy.sql.expression.Tuple.self_group">Â¶</a></dt>
<dd><p>Apply a âgroupingâ to this <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>.</p>
<p>This method is overridden by subclasses to return a âgroupingâ
construct, i.e. parenthesis. In particular itâs used by âbinaryâ
expressions to provide a grouping around themselves when placed into a larger expression, as well as by <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
constructs when placed into the FROM clause of another <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>. (Note that subqueries should be normally created using the <a href="selectable.html#sqlalchemy.sql.expression.Select.alias">Select.alias()</a> method, as many platforms require nested SELECT statements to be named).</p>
<p>As expressions are composed together, the application of <a href="#sqlalchemy.sql.expression.Tuple.self_group">self_group()</a> is automatic - end-user code should never need to use this method directly. Note that SQLAlchemyâs clause constructs take operator precedence into account -
so parenthesis might not be needed, for example, in an expression like x OR (y AND z) - AND takes precedence over OR.</p>
<p>The base <a href="#sqlalchemy.sql.expression.Tuple.self_group">self_group()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>
just returns self.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.WithinGroup">
class sqlalchemy.sql.expression.WithinGroup<a href="#sqlalchemy.sql.expression.WithinGroup">Â¶</a></dt>
<dd><p>Represent a WITHIN GROUP (ORDER BY) clause.</p>
<p>This is a special operator against so-called âordered set aggregateâ and âhypothetical set aggregateâ functions, including percentile_cont(), rank(), dense_rank(), etc.</p>
<p>Itâs supported only by certain database backends, such as PostgreSQL, Oracle and MS SQL Server.</p>
<p>The <a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a> construct extracts its type from the method <a href="functions.html#sqlalchemy.sql.functions.FunctionElement.within_group_type">FunctionElement.within_group_type()</a>. If this returns None, the functionâs .type is used.</p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.WithinGroup.filter">filter()</a>, <a href="#sqlalchemy.sql.expression.WithinGroup.over">over()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.WithinGroup">sqlalchemy.sql.expression.WithinGroup</a> (<a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
<dl>
<dt id="sqlalchemy.sql.expression.WithinGroup.filter">
method <a href="#sqlalchemy.sql.expression.WithinGroup">sqlalchemy.sql.expression.WithinGroup.</a>filter(*criterion: _ColumnExpressionArgument[bool]) â Self | <a href="#sqlalchemy.sql.expression.FunctionFilter">FunctionFilter</a>[_T]<a href="#sqlalchemy.sql.expression.WithinGroup.filter">Â¶</a></dt>
<dd><p>Produce a FILTER clause against this function.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.WithinGroup.over">
method <a href="#sqlalchemy.sql.expression.WithinGroup">sqlalchemy.sql.expression.WithinGroup.</a>over(*, partition_by: _ByArgument | None = None, order_by: _ByArgument | None = None, rows: typing_Tuple[int | None, int | None] | None = None, range_: typing_Tuple[int | None, int | None] | None = None) â <a href="#sqlalchemy.sql.expression.Over">Over</a>[_T]<a href="#sqlalchemy.sql.expression.WithinGroup.over">Â¶</a></dt>
<dd><p>Produce an OVER clause against this <a href="#sqlalchemy.sql.expression.WithinGroup">WithinGroup</a>
construct.</p>
<p>This function has the same signature as that of <a href="functions.html#sqlalchemy.sql.functions.FunctionElement.over">FunctionElement.over()</a>.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.elements.WrapsColumnExpression">
class sqlalchemy.sql.elements.WrapsColumnExpression<a href="#sqlalchemy.sql.elements.WrapsColumnExpression">Â¶</a></dt>
<dd><p>Mixin that defines a <a href="#sqlalchemy.sql.expression.ColumnElement">ColumnElement</a>
as a wrapper with special labeling behavior for an expression that already has a name.</p>
<p>New in version 1.4.</p>
<p>See also</p>
<p><a href="../changelog/migration_14.html#change-4449">Improved column labeling for simple column expressions using CAST or similar</a></p>
<p>Class signature</p>
<p>class sqlalchemy.sql.expression.WrapsColumnExpression (<a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.True_">
class sqlalchemy.sql.expression.True_<a href="#sqlalchemy.sql.expression.True_">Â¶</a></dt>
<dd><p>Represent the true keyword, or equivalent, in a SQL statement.</p>
<p><a href="#sqlalchemy.sql.expression.True_">True_</a> is accessed as a constant via the <a href="#sqlalchemy.sql.expression.true">true()</a> function.</p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.True_">sqlalchemy.sql.expression.True_</a> (sqlalchemy.sql.expression.SingletonConstant, sqlalchemy.sql.roles.ConstExprRole, <a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.TypeCoerce">
class sqlalchemy.sql.expression.TypeCoerce<a href="#sqlalchemy.sql.expression.TypeCoerce">Â¶</a></dt>
<dd><p>Represent a Python-side type-coercion wrapper.</p>
<p><a href="#sqlalchemy.sql.expression.TypeCoerce">TypeCoerce</a> supplies the <a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a>
function; see that function for usage details.</p>
<p>See also</p>
<p><a href="#sqlalchemy.sql.expression.type_coerce">type_coerce()</a></p>
<p><a href="#sqlalchemy.sql.expression.cast">cast()</a></p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.TypeCoerce.self_group">self_group()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.TypeCoerce">sqlalchemy.sql.expression.TypeCoerce</a> (sqlalchemy.sql.expression.WrapsColumnExpression)</p>
<dl>
<dt id="sqlalchemy.sql.expression.TypeCoerce.self_group">
method <a href="#sqlalchemy.sql.expression.TypeCoerce">sqlalchemy.sql.expression.TypeCoerce.</a>self_group(against: OperatorType | None = None) â <a href="#sqlalchemy.sql.expression.TypeCoerce">TypeCoerce</a>[_T]<a href="#sqlalchemy.sql.expression.TypeCoerce.self_group">Â¶</a></dt>
<dd><p>Apply a âgroupingâ to this <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>.</p>
<p>This method is overridden by subclasses to return a âgroupingâ
construct, i.e. parenthesis. In particular itâs used by âbinaryâ
expressions to provide a grouping around themselves when placed into a larger expression, as well as by <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
constructs when placed into the FROM clause of another <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>. (Note that subqueries should be normally created using the <a href="selectable.html#sqlalchemy.sql.expression.Select.alias">Select.alias()</a> method, as many platforms require nested SELECT statements to be named).</p>
<p>As expressions are composed together, the application of <a href="#sqlalchemy.sql.expression.TypeCoerce.self_group">self_group()</a> is automatic - end-user code should never need to use this method directly. Note that SQLAlchemyâs clause constructs take operator precedence into account -
so parenthesis might not be needed, for example, in an expression like x OR (y AND z) - AND takes precedence over OR.</p>
<p>The base <a href="#sqlalchemy.sql.expression.TypeCoerce.self_group">self_group()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>
just returns self.</p>
</dd></dl>
</dd></dl>
<dl>
<dt id="sqlalchemy.sql.expression.UnaryExpression">
class sqlalchemy.sql.expression.UnaryExpression<a href="#sqlalchemy.sql.expression.UnaryExpression">Â¶</a></dt>
<dd><p>Define a âunaryâ expression.</p>
<p>A unary expression has a single column expression and an operator. The operator can be placed on the left (where it is called the âoperatorâ) or right (where it is called the âmodifierâ) of the column expression.</p>
<p><a href="#sqlalchemy.sql.expression.UnaryExpression">UnaryExpression</a> is the basis for several unary operators including those used by <a href="#sqlalchemy.sql.expression.desc">desc()</a>, <a href="#sqlalchemy.sql.expression.asc">asc()</a>, <a href="#sqlalchemy.sql.expression.distinct">distinct()</a>, <a href="#sqlalchemy.sql.expression.nulls_first">nulls_first()</a> and <a href="#sqlalchemy.sql.expression.nulls_last">nulls_last()</a>.</p>
<p>Members</p>
<p><a href="#sqlalchemy.sql.expression.UnaryExpression.self_group">self_group()</a></p>
<p>Class signature</p>
<p>class <a href="#sqlalchemy.sql.expression.UnaryExpression">sqlalchemy.sql.expression.UnaryExpression</a> (<a href="#sqlalchemy.sql.expression.ColumnElement">sqlalchemy.sql.expression.ColumnElement</a>)</p>
<dl>
<dt id="sqlalchemy.sql.expression.UnaryExpression.self_group">
method <a href="#sqlalchemy.sql.expression.UnaryExpression">sqlalchemy.sql.expression.UnaryExpression.</a>self_group(against: OperatorType | None = None) â Self | Grouping[_T]<a href="#sqlalchemy.sql.expression.UnaryExpression.self_group">Â¶</a></dt>
<dd><p>Apply a âgroupingâ to this <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>.</p>
<p>This method is overridden by subclasses to return a âgroupingâ
construct, i.e. parenthesis. In particular itâs used by âbinaryâ
expressions to provide a grouping around themselves when placed into a larger expression, as well as by <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>
constructs when placed into the FROM clause of another <a href="selectable.html#sqlalchemy.sql.expression.select">select()</a>. (Note that subqueries should be normally created using the <a href="selectable.html#sqlalchemy.sql.expression.Select.alias">Select.alias()</a> method, as many platforms require nested SELECT statements to be named).</p>
<p>As expressions are composed together, the application of <a href="#sqlalchemy.sql.expression.UnaryExpression.self_group">self_group()</a> is automatic - end-user code should never need to use this method directly. Note that SQLAlchemyâs clause constructs take operator precedence into account -
so parenthesis might not be needed, for example, in an expression like x OR (y AND z) - AND takes precedence over OR.</p>
<p>The base <a href="#sqlalchemy.sql.expression.UnaryExpression.self_group">self_group()</a> method of <a href="foundation.html#sqlalchemy.sql.expression.ClauseElement">ClauseElement</a>
just returns self.</p>
</dd></dl>
</dd></dl>
<h2>Column Element Typing Utilities<a href="#column-element-typing-utilities">Â¶</a></h2>
<p>Standalone utility functions imported from the sqlalchemy namespace to improve support by type checkers.</p>
<table>
<tr><td><p><a href="#sqlalchemy.NotNullable">NotNullable</a>(val)</p></td>
<td><p>Types a column or ORM class as not nullable.</p></td>
</tr>
<tr><td><p><a href="#sqlalchemy.Nullable">Nullable</a>(val)</p></td>
<td><p>Types a column or ORM class as nullable.</p></td>
</tr>
</table>
<dl>
<dt id="sqlalchemy.NotNullable">
function sqlalchemy.NotNullable(val: _TypedColumnClauseArgument[_T | None] | Type[_T] | None) â _TypedColumnClauseArgument[_T]<a href="#sqlalchemy.NotNullable">Â¶</a></dt>
<dd><p>Types a column or ORM class as not nullable.</p>
<p>This can be used in select and other contexts to express that the value of a column cannot be null, for example due to a where condition on a nullable column:</p>
<pre>stmt = select(NotNullable(A.value)).where(A.value.is_not(None))</pre>
<p>At runtime this method returns the input unchanged.</p>
<p>New in version 2.0.20.</p>
</dd></dl>
<dl>
<dt id="sqlalchemy.Nullable">
function sqlalchemy.Nullable(val: _TypedColumnClauseArgument[_T]) â _TypedColumnClauseArgument[_T | None]<a href="#sqlalchemy.Nullable">Â¶</a></dt>
<dd><p>Types a column or ORM class as nullable.</p>
<p>This can be used in select and other contexts to express that the value of a column can be null, for example due to an outer join:</p>
<pre>stmt1 = select(A, Nullable(B)).outerjoin(A.bs)
stmt2 = select(A.data, Nullable(B.data)).outerjoin(A.bs)</pre>
<p>At runtime this method returns the input unchanged.</p>
<p>New in version 2.0.20.</p>
</dd></dl>
Previous:
<a href="expression_api.html">SQL Statements and Expressions API</a>
Next:
<a href="operators.html">Operator Reference</a>
Â© <a href="../copyright.html">Copyright</a> 2007-2024, the SQLAlchemy authors and contributors.
<p>flambÃ©! the dragon and The Alchemist image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>
Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.2.6.
Documentation last generated: Wed 03 Jul 2024 09:40:22 AM EDT

end #main-body

<p>Website content copyright Â© by SQLAlchemy authors and contributors.
SQLAlchemy and its documentation are licensed under the MIT license.</p>
<p>SQLAlchemy is a trademark of Michael Bayer. mike(&amp;)zzzcomputing.com All rights reserved. </p>
<p>Website generation by <a href="https://github.com/sqlalchemyorg/zeekofile/">zeekofile</a>, with huge thanks to the <a href="https://github.com/EnigmaCurry/blogofile">Blogofile</a>
project.</p>
<a href="https://hachyderm.io/@zzzeek">Mastodon</a>
<a href="https://fosstodon.org/@zzzeek">Mastodon</a>
End original user content
end #wrap
begin iterate through sphinx environment script_files
end iterate through sphinx environment script_files
Google tag (gtag.js)
